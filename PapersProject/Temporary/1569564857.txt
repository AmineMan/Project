Title:          cnstr_short.dvi
Creator:        www.freepdfconvert.com         
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Fri May 18 15:12:22 2012
ModDate:        Tue Jun 19 12:54:56 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      291430 bytes
Optimized:      no
PDF version:    1.7
ISIT'2012 1569564857

Long MDS Codes for Optimal Repair
Bandwidth
Zhiying Wang∗ , Itzhak Tamo∗ † , and Jehoshua Bruck∗
∗ Electrical Engineering Department, California Institute of Technology, Pasadena, CA 91125, USA
† Electrical

and Computer Engineering, Ben-Gurion University of the Negev, Beer Sheva 84105, Israel
{zhiying, tamo, bruck}@caltech.edu
N1
a
w

Abstract—MDS codes are erasure-correcting codes that can
correct the maximum number of erasures given the number of
redundancy or parity symbols. If an MDS code has r parities
and no more than r erasures occur, then by transmitting all
the remaining data in the code one can recover the original
information. However, it was shown that in order to recover a
single symbol erasure, only a fraction of 1/r of the information
needs to be transmitted. This fraction is called the repair
bandwidth (fraction). Explicit code constructions were given in
previous works. If we view each symbol in the code as a vector
or a column, then the code forms a 2D array and such codes
are especially widely used in storage systems. In this paper, we
ask the following question: given the length of the column l, can
we construct high-rate MDS array codes with optimal repair
bandwidth of 1/r, whose code length is as long as possible? In
this paper, we give code constructions such that the code length
is (r + 1) logr l.

N2
b
x

N3
c
y

N4
d
z

P1
a+b+c+d
w+x+y+z

P2
2a+w+2b+3c+d
3w+b+3x+2y+z

Figure 1. (n=6,k=4,l=2) MDS code over ﬁnite ﬁeld F4 generated by primitive
polynomial x2 + x + 1. Here 2 is a primitive element of the ﬁeld. The ﬁrst
4 nodes are systematic and the last 2 are parities. To repair N1 transmit the
ﬁrst row from every remaining node. To repair N2 transmit the second row.
To repair N3 transmit the sum of both rows. And to repair N4 transmit the
sum of the ﬁrst row and 3 times the second row.

parity nodes, and column length l = 2. One can check that
this code can correct any two erasures, therefore it is an MDS
code. In order to repair any systematic node, only 1/r = 1/2
fraction of the remaining information is transmitted. Thus this
code has optimal repair.
In [8]–[10] codes achieving the repair bandwidth lower
bound were studied where the number of systematic nodes
is less than the number of parity nodes (low code rate). For
arbitrary code rate, [4], [11] proved that the lower bound is
asymptotically achievable when the column length l goes to
inﬁnity. And [1]–[3], [6], [7], [12], [13], [15] studied codes
with more systematic nodes than parity nodes (high code
rate) and ﬁnite l, and achieved the lower bound of the repair
bandwidth. If we are interested in the code length, i.e., the
number of systematic nodes given l, low-rate codes have a
linear code length l + 1 [9], [10]; on the other hand, high-rate
constructions are relatively short. For example, suppose that
we have 2 parity nodes, then the number of systematic nodes
is only log l in all of the constructions, except for [3] it is
2 log l. In [14] it is shown that an upper bound for the code
l
length is k ≤ 1 + l (l/2), but the tightness of this bound is not
known. It is obvious that there is a big gap between this upper
bound and the constructed codes.
The main contribution of this paper is to construct codes
with 2 parity nodes and 3 log l systematic nodes. The code
uses a ﬁnite ﬁeld of size 1 + 2 log l. Moreover, we will give
a general construction of high-rate codes with (r + 1) logr l
systematic nodes for arbitrary number of parities r. It turns
out that this construction is a combination of the code in [3]
and also [1], [7], [12].
The rest of the paper is organized as follows: in Section
II we will formally introduce the repair bandwidth and the
code length problem. In Section III codes with 2 parity nodes
are constructed, and we show that the code length is 3 log l.
Generalized code constructions for arbitrary number of parities
are given in Section IV and ﬁnally we conclude in Section V.

I. I NTRODUCTION
MDS (maximum distance separable) codes are optimal
error-correcting codes in the sense that they have the largest
minimum distance given the number of parity symbols. If each
symbol is a vector or a column, we call such a code an MDS
array code. In (distributed) storage systems, each column is
usually stored in a different disk, and MDS array codes are
widely used to protect data against erasures due to their error
correction ability and low computational complexity. In this
paper, we call each symbol a column or a node, and the column
length, or the vector size of a symbol, is denoted by l.
If an MDS code has r parities, then it can correct up to r
erasures of entire columns. In this paper, we not only would
like to recover any e erasures, e ≤ r, but also care about the
efﬁciency in recovery: what is the fraction of the remaining
data transmitted in order to correct e erasures? We call this
fraction the repair bandwidth (fraction). For example, if e = r
erasures happen, it is obvious that we have to transmit all of
the remaining information, therefore, the fraction is 1. For
e = 1 erasure it was shown in [5] (which also formulated the
repair problem) that this fraction is actually lowered bounded
by 1/r. If e ≤ r symbols are erased and we repair them exactly
as they were, this fraction is lower bounded by e/r [13]. If
this bound is achieved for some code, we say it has optimal
repair. Since the repair of information is much more crucial
than redundancy, and we study mainly high-rate codes, we
will focus on the optimal repair of information or systematic
nodes. Moreover, since single erasure is the most common
scenario in practice, we assume e = 1. For example, in Figure
1, we show an MDS code with 4 systematic nodes, r = 2

1

II. P ROBLEM S ETTINGS
An (n, k, l ) MDS array code is an (n − k)-erasurecorrecting code such that each symbol is a column of length
l. The number of systematic symbols is k and the number
of parity symbols is r = n − k. We call each symbol a
column or a node, and k the code length. We assume that
the code is systematic, hence the ﬁrst k nodes of the code
are information or systematic nodes, and the last r nodes are
parity or redundancy nodes.
Suppose the columns of the code are C1 , C2 , . . . , Cn , each
being a column vector in F l , for some ﬁnite ﬁeld F. We
assume that for parity node k + i, information node j, the
coding matrix is Ai,j of size l × l, i ∈ [r ], j ∈ [k]. And the
parity columns are computed as

the sum is actually the direct sum of vector spaces. Moreover,
we know that each Si,k+t has full rank l/r.
It can be shown that (1) (2) are necessary and sufﬁcient
conditions for optimal repair [9], [14]. The proof uses interference alignment techniques ﬁrst introduced in [4], [11] for
the repair problem.
It is shown in [14] that we can further simplify our repair
strategy of node i and assume Si,j = Si , for all j = i, j ∈ [n]
by equivalent transformation of the coding matrices (probably
with an exception of the strategy of one node). Then the
subspace property becomes for any j = i, j ∈ [k], t ∈ [r ],
Si = Si At,j .

Again the equality means equality of row spans. And the sum
of subspaces satisﬁes

k

Ck+i =

∑ Ai,j Cj ,
j =1

r

∑ Si At,i = Fl .

for all i ∈ [r ]. For example, in Figure 1, the coding matrices
are A1,j = I for all j ∈ [k] and A2,j , j = 1, 2, 3, 4 are
2
0

1
3

,

2 0
1 3

,

(3)

3 0
0 2

,

1 0
0 1

Notice that if (3) is satisﬁed, we can say that Si is an invariant
subspace of At,j (multiplied on the left) for all parity nodes
k + t and all information nodes j = i. If At,j is diagonalizable
and has l linearly independent left eigenvectors, an invariant
subspace has a set of basis which are all eigenvectors of At,j .
As a result, our goal is to ﬁnd matrices At,j and their invariant
subspaces. And by using sufﬁciently large ﬁnite ﬁeld and
varying the eigenvalues of the coding matrices, we are able
to ensure that the codes are MDS. Therefore, we will ﬁrst
focus on ﬁnding eigenvectors of the coding matrices and then
discuss about the eigenvalues.
For example, in Figure 1, the matrices Si , i = 1, 2, 3, 4 are

.

Here the ﬁnite ﬁeld is F4 generated by x2 + x + 1. In our
constructions, we require that A1,j = I for all j ∈ [k]. Hence
the ﬁrst parity is the row sum of the information array. Even
though this assumption is not necessarily true for an arbitrary
linear MDS array code, it can be shown that any linear code
can be equivalently transformed into one with such coding
matrices [14].
Suppose a code has optimal repair for any systematic node
i, i ∈ [k], meaning only a fraction of 1/r data is transmitted in
order to repair it. When a systematic node i is erased, we are
going to use size l/r × l matrices Si,j , j = i, j ∈ [n], to repair
the node: From a surviving node j, we are going to compute
and transmit Si,j Cj , which is only 1/r of the information in
this node.
Notations: In order to simplify the notations, we write
Si,j and Si,k+t At,j both as matrices of size l/r × l and the
subspaces of their row spans.
Optimal repair of a systematic node i is equivalent to the
following subspace property: There exist matrices Si,j , j =
i, j ∈ [n], all with size l/r × l, such that for all j = i, j ∈
[ k ], t ∈ [r ],
Si,j = Si,k+t At,j ,
(1)

(1, 0), (0, 1), (1, 1), (1, 3).
One can check that the subspace property (3)(4) is satisﬁed for
i ∈ [4]. For instance, since S3 = (1, 1) is an eigenvector for
At,j , t = 1, 2, j = 1, 2, 4, we have S3 = S3 At,j . And it is easy
to check that S3 ⊕ S3 A2,3 = span(1, 1) ⊕ span(3, 2) = F2 .
III. C ODE C ONSTRUCTIONS

WITH

2 PARITIES

In this section, we are going to construct codes with column
length l = 2m , k = 3m systematic nodes, and r = 2 parity
nodes. Here m is some integer. As we showed in the previous
section, we can assume the coding matrices are
I
A1

where the equality is deﬁned on the row spans instead of the
matrices. And
r

∑ Si,k+t At,i = Fl .

(4)

t =1

···
···

I
Ak

,

(5)

where A1,i = I and A2,i = Ai correspond to parity 1 and 2
respectively.
Now we only need to ﬁnd coding matrices Ai ’s, and
subspaces Si ’s. For now we only care about eigenvectors of Ai ,
because eigenvectors determine the repair bandwidth. Later we
will show that using a ﬁnite ﬁeld of size linear in k, we can
choose the eigenvalues such that the code is MDS. In the
following construction, for any i ∈ [k], Ai has two different

(2)

t =1

Here the sum of two subspaces A, B of F l is deﬁned as A +
B = { a + b : a ∈ A, b ∈ B}. Obviously, the dimension of
each subspace Si,k+t At,i is no more than l/r, and the sum of
r such subspaces has dimension no more than l. This means
these subspaces intersect only on the zero vector. Therefore,

2

eigenvalues λi,0 , λi,1, each corresponding to l/2 = 2m−1
eigenvectors. Denote these eigenvectors as




vi,1
vi,l/2+1
 vi,2 
 vi,l/2+2 




Vi,0 =  .  , Vi,1 = 
,
.
.
 . 


.
.
vi,l/2

subspace of A2 . So S1 = S1 A2 . If the two eigenvalues of Ai
are distinct, it is easy to show that Si ⊕ Si Ai = F4 , ∀i ∈ [6].
The above example shows that for m = 1, 2, the constructed
code has optimal repair. It is true in general, as the following
theorem suggests.

vi,l

Theorem 2 Construction 1 is a code with optimal repair bandwidth 1/2 for rebuilding any systematic node.

for eigenvalues λi,0, λi,1 , respectively. Therefore, Ai can be
computed as
Ai =

Vi,0
Vi,1

−1

λi,0 I l × l
2

2

λi,1 I l × l
2

2

Vi,0
Vi,1

Proof: By symmetry of the ﬁrst two cases in the construction, we are only going to show that the rebuilding of node
i, i ∈ [m] ∪ [2m + 1, 3m] is optimal. Namely, the subspace
property (6)(7) is satisﬁed. Recall that Si A j = Si is equivalent
to Si being an invariant subspace of A j .
Case 1: i ∈ [m].

.

By abuse of notations, we also use Vi,0 , Vi,1 to represent the eigenspace corresponding to λi,0 , λi,1 , respectively. Namely, Vi,0 = span{vi,1, . . . , vi,l/2} and Vi,1 =
span{vi,l/2+1, . . . , vi,l }.
When a systematic node i is erased, i ∈ [k], we are going
to use Si to rebuild it. The subspace property becomes
Si = Si A j ,

∀ j = i, j ∈ [k],

•

(6)
•

Si + Si A i = F l .

(7)
•

In the following construction, e a , a ∈ [0, l − 1], are some
basis of F l , for example, one can think of them as the standard
basis. The subscript a is represented by its binary expansion,
a = ( a1 , a2 , . . . , am ). For example, if l = 16, m = 4, a = 5,
then e5 = e(0,1,0,1) and a1 = a3 = 0, a2 = a4 = 1.
In order to construct the code, we ﬁrst deﬁne 3 sets of
vectors for i ∈ [m]:
Pi,0
Pi,1
Qi

•

When j ∈ [tm + 1, (t + 1)m], j − tm = i, t ∈ {0, 1},
deﬁne B = {e a : a j = 1 − t, ai = 0} ∪ {e a + eb : a j +
b j = 1, ai = bi = 0, az = bz , ∀z = i, j}. Then it is easy
to see that Si = span( Pi,0) = span( B). Moreover, each
vector in set B is an eigenvector of A j , therefore Si is an
invariant subspace of A j .
When j − m = i, Si = Vj,0 = span( Pi,0), so Si is an
eigenspace of A j .
When j ∈ [2m + 1, 3m], we can see that every vector
in Pi,0 is a vector in Vj,0 = span( Pj,0) or in Vj,1 =
span( Pj,1 ), hence it is an eigenvector of A j .
When j = i, consider a vector e a ∈ Pi,0, then ai = 0.
And e a = (e a + eb ) − eb where bi = 1, b j = a j for all
j = i. Here both e a + eb and eb are eigenvectors of Ai .
e a Ai

= { e a : a i = 0 },
= { e a : a i = 1 },
= {e a + eb : ai + bi = 1, a j = bj , ∀ j = i }.

= ( e a + eb ) Ai − eb Ai
= λi,0 (e a + eb ) − λi,1 eb
= (λi,0 − λi,1 )eb + λi,0 e a .

Because λi,0 = λi,1 , we get span{e a Ai , e a } =
span(e a , eb ). Hence Si Ai + Si = span{e a , eb : ai =
0, bi = 1, a j = b j , ∀ j = i } = F l .

For example, if m = 2, i = 1, then P1,0 = {e(0,0), e(0,1) } =
{e0 , e1 }, P1,1 = {e(1,0) , e(1,1)} = {e2 , e3 }, and Q1 = {e(0,0) +
e(1,0), e(0,1) + e(1,1) } = {e0 + e2 , e1 + e3 }. Notation: The
subscript i for sets Pi,u , Qi and ai (the i-th digit of vector a)
is written modulo m. For example, if i ∈ [tm + 1, (t + 1)m]
for some integer t, then Pi,u := Pi−tm,u.

Case 2: i ∈ [2m + 1, 3m].
•
•

2m )

Construction 1 The (n = 3m + 2, k = 3m, l =
code has
coding matrices Ai , i ∈ [k], each with two distinct eigenvalues,
and eigenvectors Vi,0 , Vi,1. When node i is erased, we are going
to use Si to rebuild. We construct the code as follows:
1) For i ∈ [m], Vi,0 = span( Qi ), Vi,1 = span( Pi,1 ), Si =
span( Pi,0).
2) For i ∈ [m + 1, 2m], Vi,0 = span( Pi,0), Vi,1 =
span( Qi ), Si = span( Pi,1 ).
3) For i ∈ [2m + 1, 3m], Vi,0 = span( Pi,0), Vi,1 =
span( Pi,1), Si = span( Qi ).

•

Example 1 Deleting the node N4, Figure 1 is a code using
Construction 1 and l = 2. Another example of l = 4 is
shown in Figure 2. One can check (6) holds. For instance,
S1 = span{e0 , e1 } = span{e0 + e1 , e1 } is an invariant

•

When j = i − m or j = i − 2m, Si = span( Qi ) is an
eigenspace of A j .
When j ∈ [tm + 1, (t + 1)m], and j = i − tm for t ∈
{0, 1}, deﬁne D = {e a + eb : a j = bj = 1 − t, ai + bi =
1, az = bz , ∀z = i, j} ∪ {e a + eb + ec + ed : a j = b j =
0, c j = d j = 1, ai + bi = 1, ci + di = 1, az = bz =
cz = dz , ∀z = i, j}. We can see that Si = span( Qi ) =
span( D ) and every vector in D is an eigenvector of A j .
When j ∈ [2m + 1, 3m], j = i. We can see that Qi =
{e a + eb : a j = bj = 0, ai + bi = 1, az = bz , ∀z = i, j} ∪
{e a + eb : a j = bj = 1, ai + bi = 1, az = bz , ∀z = i, j}.
Apparently, every vector in Qi is a sum of two vectors
in Pj,0 or two vectors in Pj,1. So Si = span( Qi ) is an
invariant subspace of A j .
When j = i, consider any e a + eb ∈ Qi , where ai =
1, bi = 0, az = bz , ∀z = i. We have

(e a + eb ) Ai = λi,1 e a + λi,0 eb .

3

1st eigenspace
of Ai
2nd eigenspace
of Ai
Si

N1
e0 + e2
e1 + e3
e2
e3
e0
e1

N2
e0 + e1
e2 + e3
e1
e3
e0
e2

N3
e0
e1
e0 + e2
e1 + e3
e2
e3

N4
e0
e2
e0 + e1
e2 + e3
e1
e3

N5
e0
e1
e2
e3
e0 + e2
e1 + e3

N6
e0
e2
e1
e3
e0 + e1
e2 + e3

Figure 2. (n=8,k=6,l=4) code. The ﬁrst parity node is assumed to be the row sum, and the second parity is computed using coding matrices A i . In order to
rebuild node i, Si is multiplied to each surviving node. The ﬁrst 2m = 4 nodes have optimal access, and the last m = 2 nodes have optimal update.

Because λi,0 = λi,1, we get span{(e a + eb ) Ai , e a +
eb } = span{e a , eb }. Thus Si Ai + Si = span{e a , eb :
ai = 1, bi = 0, az = bz , ∀z = i } = F l .

Construction 2 Let the elements of the code be over F q , with
q ≥ 2m + 1. Let c be a primitive element in F q and write
< i >:= i mod m. Assign the eigenvalues of the coding
matrices to be

It should be noted that if we shorten the code and keep only
the ﬁrst 2m systematic nodes in the code, then it is actually
equivalent to the code in [3]. The repairing of the ﬁrst 2m
nodes does not require computation within each remaining
node, since only standard bases are multiplied to the surviving
columns (e.g. Figure 2). We call such repair optimal access.
It is shown in [14] that if a code has optimal access, then
the code has no more than 2m nodes. On the other hand, the
shortened code with the last m systematic nodes in the above
construction is equivalent to that of [1], [7], [12]. Since the
coding matrices Ai , i ∈ [2m + 1, 3m] are all diagonal, every
information entry is included in only r + 1 entries in the code.
We say such a code has optimal update. In [14] it is proven
that an optimal-update code with diagonal coding matrices has
no more than m nodes. Therefore, our code is a combination
of the longest optimal-access code and the longest optimalupdate code, which provides tradeoff among access, update,
and the code length. The shortening technique was also used
in [9] in order to get optimal-repair code with different code
rates.
In addition, if we try to extend an optimal-access code C
with length 2m to a code D with length k, so that C is a
shortened code of D , then the following theorem shows that
k = 3m is largest code length. The proof is omitted and can
be found in the long version of this paper [16]. Therefore, our
construction is longest in the sense of extending C .

λi,s =

(8)

(λ1,0 , . . . , λ6,0 ; λ1,1, . . . , λ6,1 ) = (1, 2, 1, 2, 4, 3; 4, 3, 4, 3, 1, 2).
One can check that this assignment makes the code MDS.
IV. C ODES WITH A RBITRARY N UMBER OF PARITIES
In this section, we will give constructions of codes with
arbitrary number of parity nodes. Our code will have l = r m
rows, k = (r + 1)m systematic nodes, and r parity nodes, for
any r ≥ 2, m ≥ 1.
Suppose As,i is the coding matrix for parity node k + s and
information node i. From Section II, we assume A1,i = I for
all i. In our construction, we are going to add the following
assumptions. Every As,i has r distinct eigenvalues, each corresponding to l/r = r m−1 linearly independent eigenvectors,
for s ∈ [2, r ]. Moreover, given an information node i ∈ [k],
all matrices As,i , s ∈ [2, r ], share the same eigenspaces
Vi,0 , Vi,1 , . . . , Vi,r −1. If these eigenspaces correspond to eigenvalues λi,0 , λi,1 , . . . , λi,r −1 for A2,i , then we assume they
1
correspond to eigenvalues λs−1 , λs−1 , . . . , λs−−1 for As,i . By
i,0
i,1
i,r
abuse of notations, Vi,u represents both the eigenspace and the
l/r × l matrix containing l/r independent eigenvectors. Under
these assumptions, it is easy to see that if we write As,i as


 −1  s −1

λi,0 I
Vi,0
Vi,0



 

.
.
..

.
.

 
,
.
.
.

s −1
Vi,r −1
Vi,r −1
λi,r −1 I

Next let us discuss about the ﬁnite ﬁeld size of the code. In
order to make the code MDS, it is equivalent that we should be
able to recover from any two column erasures. In other words,
any 1 × 1 or 2 × 2 submatrices of the matrix (5) should be
invertible. Therefore, all eigenvalues λi,s should be nonzero,
i ∈ [k], s ∈ {0, 1}. Moreover, the following matrix should be
invertible for all i = j:
I
Aj

i ∈ [2m]
i ∈ [2m + 1, 3m]

If we have an extra systematic column with A3m+1 = I (see
column N4 in Figure 1), we can use a ﬁeld of size 2m + 2
and simply multiply the above eigenvalues by c. For example,
when m = 1, the coefﬁcients in Figure 1 are assigned using
the above method, where the ﬁeld size is 4 and c = 2. For
another example, if m = 2, we can use ﬁnite ﬁeld F5 and
c = 2, then assign the eigenvalues to be

Theorem 3 Any extended code of an optimal-access code of
length 2m will have no more than 3m systematic nodes.

I
Ai

c<i>+sm,
c<i>+(1−s)m,

l
l
where the identity matrices are of size r × r , then As,i =
s −1
A2,i , for all s ∈ [r ]. Hence, we are going to write Ai = A2,i ,
thus As,i = As−1, and our construction will only focus on the
i
matrix Ai . As a result, the subspace property becomes

.

Or equivalently, Ai − A j should be invertible.
The following construction with ﬁeld of size 2m + 1 actually satisﬁes the above condition and guarantees that the code
has optimal repair. The proof is in [16].

Si = Si A j , ∀ j = i, j ∈ [k]

4

(9)

Si + Si A i + Si A2 + · · · + Si Ar −1 = F l
i
i

(10)

property gives more insights on the structure of the codes,
and simpliﬁes the proof of optimal repair.
If we require that the code rate approaches 1, i.e., r being
a constant and m goes to inﬁnity, then the column length l
is exponential in the code length k. However, if we require
the code rate to be roughly a constant fraction, i.e., m being
a constant and r goes to inﬁnity, then l is polynomial in k.
Therefore, depending on the application, we can see a tradeoff
between the code rate and the code length.
It is still an open problem what is the longest optimal-repair
code one can build given the column length l. Also, the bound
of the ﬁnite ﬁeld size used for the codes may not be tight
enough. Unlike the constructions in this paper, the ﬁeld size
may be reduced when we assume that the coding matrices do
not have eigenvalues or eigenvectors (are not diagonalizable).
These are our future work directions.
ACKNOWLEDGEMENT
This work was partially supported by an NSF grant ECCS0801795 and a BSF grant 2010075.
R EFERENCES

Note that such choice of eigenvalues is not the unique way
to construct the matrices, but it guarantees that the code has
optimal repair bandwidth. Also, when the ﬁnite ﬁeld size is
large enough, we can ﬁnd appropriate values of λi,u ’s such that
the code is MDS. At last, since each Vi,u has dimension l/r
and corresponds to l/r independent eigenvectors, we know
that any vector in the subspace Vi,u is an eigenvector of Ai .
Let {e0 , e1 , . . . , er m −1 } be the standard basis of F l . And
we are going to use the r-ary expansion to represent the
index of a base. An index a ∈ [0, r m − 1] is written as
a = ( a1 , a2 , . . . , am ), where ai is its i-th digit. For example,
when r = 3, m = 4, we have e5 = e(0,0,1,2). Deﬁne for
i ∈ [k], u ∈ [0, r − 1] the following sets of vectors:
Pi,u

= { e a : a i = u },
r −1

Qi

= { ∑ e a : a j ∈ [0, r − 1], j = i }.
a i =0

So Pi,u is the set of bases whose index is u in the i-th digit.
The sum in Qi is over all e a such that the j-th digit of a is
some ﬁxed value for all j = i, and the i-th digit varies in
[0, r − 1]. In other words, a vector in Qi is the summation
of the corresponding bases in Pi,u , ∀u. For example, when
r = 3, m = 2, P1,0 = {e(0,0) , e(0,1), e(0,2) } = {e0 , e1 , e2 },
P1,1 = {e3 , e4 , e5 }, P1,2 = {e6 , e7 , e8 }, and Q1 = {e0 + e3 +
e6 , e1 + e4 + e7 , e2 + e5 + e8 }.
In the following, all of the subscript i for sets Pi,u , Qi and
for digit ai are computed modulo m. For example, if i ∈
[tm + 1, (t + 1)m] for some integer t, then Qi := Qi−tm .

[1] V. R. Cadambe, C. Huang, and J. Li,“Permutation code: optimal exactrepair of a single failed node in MDS code based distributed storage
systems,” in ISIT, 2011.
[2] V. R. Cadambe, C. Huang, S. A. Jafar, and J. Li, “Optimal repair of
MDS codes in distributed storage via subspace interference alignment”,
Tech. Rep. arXiv:1106.1250, 2011.
[3] V. R. Cadambe, C. Huang, J. Li, and S. Mehrotra,“ Polynomial length
MDS codes with optimal repair in distributed storage systems”, in
Proceedings of 45th Asilomar Conference on Signals Systems and
Computing, Nov 2011.
[4] V. R. Cadambe, S. A. Jafar, and H. Maleki, “Minimum repair bandwidth
for exact regeneration in distributed storage,” in Wireless Network
Coding Conference (WiNC), Jun 2010.
[5] A. Dimakis, P. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran,
“Network coding for distributed storage systems,” IEEE Trans. on
Information Theory, vol. 56, no. 9, pp. 4539–4551, 2010.
[6] D. S. Papailiopoulos, and A.G. Dimakis, “Distributed storage codes
through Hadamard designs, ” in ISIT, 2011.
[7] D. S. Papailiopoulos, A.G. Dimakis, and V. R. Cadambe, “ Repair Optimal Erasure Codes through Hadamard Designs,” in Allerton Conference
on Control, Computing, and Communication, Urbana-Champaign, IL,
2011.
[8] K. V. Rashmi, N. B. Shah, P. V. Kumar, and K. Ramchandran, “Explicit
Construction of Optimal Exact Regenerating Codes for Distributed
Storage,” in Allerton Conference on Control, Computing, and Communication, Urbana-Champaign, IL, 2009.
[9] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Interference alignment in regenerating codes for distributed storage: necessity
and code constructions,” IEEE Trans. on Information Theory, vol 56,
no. 4, pp. 2134–2158, 2012.
[10] C. Suh and K. Ramchandran, “Exact-Repair MDS Code Construction
Using Interference Alignment,” IEEE Trans. on Information Theory, vol
57, no. 3, pp. 1425–1442, 2011.
[11] C. Suh and K. Ramchandran, “On the existence of optimal exact-repair
MDS codes for distributed storage,” Tech. Rep. arXiv:1004.4663, 2010.
[12] I. Tamo, Z. Wang, and J. Bruck, ”MDS array codes with optimal
rebuilding,” in ISIT, 2011.
[13] I. Tamo, Z. Wang, and J. Bruck, “Zigzag codes: MDS array codes with
optimal rebuilding,” Tech. Rep. arXiv:1112.0371, 2011.
[14] I. Tamo, Z. Wang, and J. Bruck, “Access vs. bandwidth in codes for
storage,” accepted by ISIT, 2012.
[15] Z. Wang, I. Tamo, and J. Bruck, “ On codes for optimal rebuilding
access,” in Allerton Conference on Control, Computing, and Communication, Urbana-Champaign, IL, 2011.
[16] Z. Wang, I. Tamo, and J. Bruck, “Long MDS codes for
optimal repair bandwidth”, Tech. Rep. Available at http :
//paradise.caltech.edu/etr.html.

Construction 3 The (n = (r + 1)m + r, k = (r + 1)m, l =
r m ) code is constructed as follows. For information node
i ∈ [tm + 1, (t + 1)m], t ∈ [0, r − 1], the u-th eigenspace
(u ∈ [0, r − 1]) of coding matrix Ai and the rebuilding
subspace Si are deﬁned as: Vi,u = span( Pi,u ), ∀u = t,
Vi,t = span( Qi ), and Si = span( Pi,t ). For information
node i ∈ [rm + 1, (r + 1)m], the eigenspaces and rebuilding subspaces are Vi,u = span( Pi,u ), ∀u ∈ [0, r − 1], and
Si = span( Qi ).
Theorem 4 Construction 3 has optimal repair bandwidth 1/r
when rebuilding one systematic node.
The proof is in [16]. Again, this construction can be
shortened to an optimal-access code of length rm [3] and an
optimal-update code of length m [1], [7], [12].
Moreover, the ﬁnite ﬁeld size of this code can be bounded
by kr −1r m−1 + 1 (see details in [16]), but we believe that there
is still a large space to improve this bound.
V. C ONCLUSIONS
In this paper, we presented a family of codes with parameters (n = (r + 1)m + r, k = (r + 1)m, l = r m ) and they are
so far the longest high-rate MDS code with optimal repair.
The codes were constructed using eigenspaces of the coding
matrices, such that they satisfy the subspace property. This

5

