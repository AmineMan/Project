Creator:        TeX
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Fri May 18 17:35:00 2012
ModDate:        Tue Jun 19 12:54:57 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      589268 bytes
Optimized:      no
PDF version:    1.6
ISIT'2012 1569566895

Regenerating Codes for Errors and Erasures in
Distributed Storage
K. V. Rashmi, Nihar B. Shah, Kannan Ramchandran, Fellow, IEEE, and P. Vijay Kumar, Fellow, IEEE
Abstract—Regenerating codes are a class of codes proposed
for providing reliability of data and efﬁcient repair of failed
nodes in distributed storage systems. In this paper, we address
the fundamental problem of handling errors and erasures during
the data-reconstruction and node-repair operations. We provide
explicit regenerating codes that are resilient to errors and
erasures, and show that these codes are optimal with respect
to storage and bandwidth requirements. As a special case, we
also establish the capacity of a class of distributed storage
systems in the presence of malicious adversaries. While our
code constructions are based on previously constructed ProductMatrix codes, we also provide necessary and sufﬁcient conditions
for introducing resilience in any regenerating code.

α α α	   α	  

α α

k=2	  
α α α	   α	   k=2	  

α α

α α

DCDC

α α

α α

α α

α α

β	   β	  
d=3	  
d=3	  
β	   β	  

new	  
new	  
node	  
node	  

β	   β	  

α	   α	  
(a)

(b)

Fig. 1: An example of the system parameters under a regenerating code (in the absence of errors/erasures). The system
comprises of n = 5 storage nodes: (a) reconstruction is
accomplished from any k = 2 nodes, (b) repair from any
d = 3 nodes.

I. I NTRODUCTION
Distributed storage systems play a vital role in today’s age
of big data. For cost considerations, these storage systems
often employ commodity hardware, which makes failures a
norm rather than an exception. In order to safeguard the
precious data against such failures, the data is typically stored
in a redundant manner. In this paper, we consider a distributed
storage system consisting of n storage nodes in a network,
each having a capacity to store α symbols over a ﬁnite ﬁeld
Fq . Data comprising B symbols (the message) is to be stored
across these n nodes. An end-user (called a data collector)
must be able to reconstruct the entire message by downloading
the data stored in any k of these n nodes. It follows that
such a system can tolerate failure of any (n − k) nodes, and
under solely this requirement, can be realised using any [n, k]
maximum distance separable (MDS) code.
Frequent node failures also call for efﬁcient handling of
the failure events. When a storage node fails, it is replaced
by a new, empty node. This replacement node is required to
obtain the data that was stored previously in the failed node,
by downloading data from the remaining nodes in the network.
We will term this process as repair or regeneration of a node.
A typical means of accomplishing this is to download the
entire message from the network, and extract the desired data
from it. However, downloading the entire message, when it
1
eventually stores only a fraction k of it, is clearly wasteful of
the network resources.
‘Regenerating codes’ [1] are a class of codes that aim to
reduce the amount of download during repair, while retaining
the storage efﬁciency of traditional MDS codes. Under the

operation of a regenerating code, a replacement node connects
to any d (≥ k) existing nodes (termed helper nodes), and
downloads β symbols from each. This setting is illustrated in
Fig. 1. With regenerating codes, the total amount of data dβ
downloaded for repair is much smaller than the total size of the
message B. It is shown in [1] that the parameters associated
with a regenerating code must necessarily satisfy
k−1

B≤

min (α, (d − i)β) .

(1)

i=0

A regenerating code is said to be optimal if it satisﬁes this
bound with equality. Since both storage and bandwidth come
at a cost, it is naturally desirable to minimize both α as well
as β. However, it can be deduced (see [1]) that achieving
equality in (1), for ﬁxed values of B and [n, k, d], leads
to a tradeoff between the storage space α and the amount
of download for repair dβ. The two extreme points in this
tradeoff are termed the minimum storage regenerating (MSR)
and minimum bandwidth regenerating (MBR) points. These
points have been well studied in the literature, and several
explicit constructions of codes operating at these points are
available [2]–[8]. It has also been shown in [8] that essentially
all other points on the tradeoff curve are not achievable.
In this paper, we address the problem of handling errors
and erasures in distributed storage networks using regenerating
codes. In particular, we are interested in codes that can
perform reconstruction and efﬁcient repair in the presence
of errors and erasures at the nodes or in the links. Such
codes are clearly useful in handling errors and packet losses
occurring in the network. In addition, such codes can also be
used to provide security in distributed storage systems, where
malicious adversaries may corrupt the data stored in some
nodes in the system.

K. V. Rashmi, Nihar B. Shah and Kannan Ramchandran are with the
Dept. of EECS, University of California, Berkeley, CA 94703, USA. Email:
{rashmikv, nihar, kannanr}@eecs.berkeley.edu. P. Vijay Kumar is with the
Dept. of ECE, Indian Institute Of Science, Bangalore, India. Email: vijay@ece.iisc.ernet.in. P. Vijay Kumar is also an adjunct faculty member of
the Electrical Engineering Systems Department at the University of Southern
California, Los Angeles, CA 90089-2565.
This project is supported in part by an AFOSR grant (FA9550-10- 1-0567).

1

2

n1

a

n2

c

n3

a + 3c

n4

a + 8c

n5

4a + 2c

n6

4a + 3c

b
1
×1
1
7a + 2b + 3d × 1
1
3a + 6b + 8d ×
1
1
a + 9b + 2d ×
1
1
9a + b + 3d ×
1
d

8a +

2

(c + d)
d)
(c +
b+3

a

✓

b

MDS in a, b, (c+d)
Decode a, b and (c+d) even under one error
Retain a and b

Fig. 2: An example of a universally resilient MSR code with parameters [n = 6, k = 2, d = 3], (B = 4, α = 2, β = 1). Also
depicted is an instance of one error correction during repair of node 1, by connecting to (d + 2) = 5 nodes.
While we were writing this paper, we came across a
contemporaneous independent work [10] that is related to
the present paper, and deals with byzantine fault tolerance
using product-matrix codes of [2]. The authors use a CRC
to check the integrity of data during repair and reconstruction,
and a feedback scheme to iteratively correct them. However,
CRC based schemes are not applicable in settings such as
protection against malicious adversaries, since the CRC can
also be corrupted by the adversary. The present paper takes a
more fundamental look at the problem of handling errors and
erasures in regenerating codes.
The rest of the paper is organized as follows. The system
model is described in Section II, and outer bounds for this
model are also provided in this section. Explicit constructions
of error-resilient regenerating codes are provided in Section III.
Necessary and sufﬁcient conditions for providing error and
erasure resiliency in any regenerating code are presented in
Section IV.

The aspect of security in distributed storage systems employing regenerating codes is studied in [9], where an outer
bound is provided for the total amount of data that can be
stored securely in the presence of malicious adversaries. The
model presented in [9] considers correction of a ﬁxed number of errors, by designing encoding and storage algorithms
speciﬁcally for this purpose. It is also shown that the code
in [8] achieves this bound with an appropriate choice of the
underlying MDS code, for the case d = n − 1 at the MBR
point. However, apart from this case, no other constructions
of secure regenerating codes are known in the literature.
In the present paper, we provide a new approach for
handling errors and erasures in regenerating codes. Under our
system model, the data is encoded and stored assuming no
error/erasure-resiliency requirements. The task of correcting
the errors or erasures is performed in the decoding stage by
downloading a larger amount of data. In contrast to [9], our
approach allows for choosing a different level of resiliency
during each event of repair or reconstruction, depending on the
prevalent network state. A second advantage of our approach
is that it allows for introducing resilience in regenerating codes
that were not designed for handling errors and erasures.
We present explicit code constructions for the parameters
(i) MSR, all [n, k, d ≥ 2k − 2] and (ii) MBR, all [n, k, d]. In
addition, we show the optimality of these codes through tight
outer bounds on the storage and bandwidth requirements. This
establishes the capacity of such systems for these parameters.
Moreover, this also establishes the capacity of regenerating
codes in the presence of malicious adversaries for these parameters, which had remained open. The decoding algorithms have
a (polynomial) complexity, identical to that of Reed-Solomon
codes. The codes presented here are based on a ‘ProductMatrix’ construction introduced in [2], that also possess other
appealing properties such as linearity, scalability, and ease of
implementation. An example of an MSR error/erasure-resilient
code is depicted in Fig. 2.
A natural question that follows is whether any regenerating
code can be made resilient to errors and erasures in this fashion. In this paper, we also answer this question by providing
necessary and sufﬁcient conditions for a regenerating code to
be resilient to errors and erasures. It turns out that, to date,
the product-matrix codes are the only codes that satisfy these
properties.

II. S YSTEM M ODEL
We consider a block-based model where the message is
divided into blocks, and there is no coding across the blocks.
All operations of encoding, decoding and repair are performed
independently across the blocks. Thus the regenerating code
parameters (for the error-free case) described in Section I
can be considered as pertaining to a single block of data.
More concretely, we consider a block to consist of B message
symbols, and the storage capacity in each of the n nodes to
be α symbols per block. One can reconstruct the B-message
symbols by downloading the data pertaining to this block from
any subset of k nodes, and regenerate the data stored in any
node by downloading β symbols each (pertaining to this block)
from any d nodes.
We assume that the granularity of any error or erasure is
one block. In other words, we assume that during repair, all
the β symbols passed by a helper node suffer the same fate:
either all these β symbols are erased, or all are in error, or all
are perfectly received. Similarly, during reconstruction, all the
α symbols passed by a node are assumed to suffer the same
fate.
The assumption of block errors/erasures can accurately
model several scenarios of interest, two of which are described
here. Consider handling of packet drops during transmission
across a network. The size of a packet during reconstruction

2

3

α α α	   α	  

α α

α α α	   α	  

α α

DCDC
κ=3	  
κ=3	  

α α α	   α	  

α α

α α

α α

α α

new	  
new	  
node	  
node	  

β	   β	  
β	   β	  

Δ=4	  
Δ=4	  

β	   β	  

α	   α	  

k + s + 2t ≤ n

β	   β	  

(a)

Fig. 3: The system setting for an (s = 1, t = 0)-resilient
regenerating code with k = 2 and d = 3. Here, connectivity
during (a) reconstruction is κ = k + 1 = 3, and (b) repair is
∆ = d + 1 = 3.
and repair can be assumed to be a multiple of α and β
(since the packet size will usually be much larger than these
parameters). Thus, when a packet is delayed or dropped, all
the α or β symbols corresponding to a block are erased. In
the security scenario, to account for compromise of any node
or link to a malicious adversary, one needs to protect against
corruption of the entire data on that node or link. Thus, we
can model the security scenario in our framework by simply
considering the entire data as a single block.
We note that the absence of this assumption will allow
arbitrarily scattered errors and erasures in the model. It can
be shown that codes attempting to guard against such scattered errors/erasures require signiﬁcantly larger overheads. As
discussed above, many applications can be modelled as having
block errors, thus avoiding these overheads.
We now deﬁne formally, the error/erasure handling capability of a regenerating code.
Deﬁnition 1 ((s, t)-resilient code): A regenerating code is
(s, t)-resilient if it can correct upto s erasures and t errors
during repair as well as reconstruction.
As discussed previously, under our system model, errors and
erasures are corrected by downloading additional data during
reconstruction or repair. One way to obtain additional data is
to connect to a larger number of nodes, and we choose this
approach. More precisely, we allow a connectivity of ∆ (≥ d)
nodes during repair and κ (≥ k) nodes during reconstruction.
The parameters ∆ and κ depend on the error/erasure correcting
capability expected out of the system. Fig. 3 depicts the (1, 0)resilient version of the system in Fig. 1.
We now provide an outer bound on the capacity of resilient
regenerating codes. The bound is obtained by adapting the
outer bound of [9] (for the omniscient adversary case) to our
system model, and extending it to handle erasures as well.
Theorem 1: A (s, t)-resilient regenerating code, connecting
to ∆ and κ nodes for repair and reconstruction respectively,
must satisfy

III. E RROR / ERASURE - RESILIENT REGENERATING CODES
We provide explicit constructions of universally resilient
MSR and MBR codes for
1) MSR, all parameters [n, k, d ≥ 2k − 2] , and
2) MBR, all parameters [n, k, d],
which meet the outer bound provided in Theorem 1. Thus,
this also establishes the capacity of such a system for these
parameter values. These codes are based on product-matrix
(PM) codes that were introduced in [2].
As discussed in Section II, in our approach, the encoding
algorithm is identical to the error/erasure free case. Hence, we
ﬁrst brieﬂy describe the product-matrix code construction for
the error/erasure free case [2], which meets the bound in (1).
We then present the decoding algorithms (for both repair and
reconstruction) that can handle s erasures and t errors for all
values of s and t satisfying (3), with ∆ = (d + s + 2t) and
κ = (k + s + 2t). These parameters satisfy the bound in
Theorem 1 with equality, thereby establishing the optimality
of these codes.
We begin with the minimum storage case, and subsequently
present the minimum bandwidth case. The example depicted
in Fig. 2 is an optimal, universally resilient MSR code.

k−1

min (α, (d − i)β)

(3b)

where (3a) represents the connectivity required during repair,
and (3b) during reconstruction.
In many applications of interest, it may be desired to
provide different levels of reliability during different instances
of reconstruction and repair. For instance, under changing
network states in the packet erasure setting, or varying threat
levels under the security setting. We deﬁne codes that possess
such a property as universally resilient codes.
Deﬁnition 2 (Universally resilient code): A regenerating
code is universally resilient if it is simultaneously (s, t)resilient for all s and t satisfying (3).
Thus a universally resilient code can correct upto s erasures
and t errors by downloading β (or α) symbols each from s+2t
additional nodes during repair (or reconstruction), as long as
d + s + 2t ≤ n − 1 (or k + s + 2t ≤ n).
In the next section, we present constructions of productmatrix codes that are universally resilient and optimal. Before
moving on to the constructions, we brieﬂy digress to explore
some connections with network coding.
Relation to Network Coding: The regenerating codes problem described above, if relaxed to the requirement of repair
of only the systematic nodes, turns out to be a non-multicast
network coding problem (see [12, Section I-C]). While the
occurrence of errors and erasures in multicast network coding
are well studied in the literature [13]–[15], the results of
the present paper lead to a class of non-multicast networks
for which the error/erasure capacity of the network can be
achieved by codes that are linear, deterministic and explicit.

(b)

B≤

proof is available in [11].
We will call an (s, t)-resilient regenerating code as optimal
if it meets the bound in Theorem 1. Clearly, for (s, t)resilience, we need
d + s + 2t ≤ n − 1
(3a)

(2)

i=0

where d = ∆ − s − 2t and k = κ − s − 2t.
Proof (sketch): The bound can be derived either using
cut-set arguments in an information ﬂow graph as in [1], [9] or
using information theoretic arguments as in [8]. The complete

3

4

The replacement for the failed node f connects to an
arbitrary set {hj | j = 1, . . . , ∆} of ∆ nodes. To facilitate
repair of node f , node hj computes the inner product ψ t M φf
hj
and passes on this value to the replacement node. Letting
mf = M φf , we can write the symbol passed by node hj
as ψ t mf . Thus the ∆ symbols obtained at the destination
hj
are Ψrep mf , where

A. Universally resilient MSR Codes
MSR codes use the minimum possible storage at each node.
Since the data from any k nodes should sufﬁce to reconstruct
all the B message symbols, each node must necessarily store
1
at-least a fraction k of the entire data. Hence for an MSR
code we have α = B . To meet the bound (1) with equality
k
(in absence of errors/erasures), an MSR code must satisfy
B = kα,

dβ = α + (k − 1)β .

(4)

t

Ψrep = ψ h ψ h . . . ψ h
1

In this section we present explicit constructions of optimal,
universally resilient MSR codes for all parameter values
[n, k, d ≥ 2k − 2]. The code is designed for the case
d = 2k − 2, which can be extended to any d > 2k − 2 via
the shortening technique for MSR codes provided in [2], [4].
When d = 2k − 2, from (4), we get
α = (k − 1)β, B = k(k − 1)β .

(5)

α = (k − 1), B = k(k − 1) = α (α + 1), β = 1 , (6)

Since S1 and S2 are symmetric matrices, the replacement node
has access to φt S1 and φt S2 . Using this it can obtain φt S1 +
f
f
f
λf φt S2 , which is precisely the data previously stored in node
f
f.
Theorem 2 (MSR Reconstruction): In the MSR code presented, a data-collector can reconstruct all the B message
symbols by downloading data stored in any κ = k + s + 2t
nodes in the presence of upto s (block) erasures and t (block)
errors.
Proof (sketch): The data reconstruction property of the
code in the error-free case, as shown in [2], implies that the
data passed by the κ nodes are MDS over the ﬁnite ﬁeld Fα .
q
Over this ﬁnite ﬁeld, the message is of size k, and the minimum distance of this MDS code is (κ − k + 1) = (s + 2t + 1).
This guarantees reconstruction of the k source symbols over
Fα , and equivalently the kα = B source symbols over Fq , in
q
the presence of upto s erasures and t errors.
Explicit data-reconstruction algorithms are provided in [11].

and then concatenating this code β times in parallel.
The PM-MSR code in [2] can be described in terms of
an (n × α ) code matrix C = ΨM , with the ith row of
C containing the α symbols stored in node i. The (n × d)
encoding matrix Ψ is of the form Ψ = [Φ ΛΦ], where Φ
is an (n × α ) matrix and Λ is an (n × n) diagonal matrix
satisfying: (a) any α rows of Φ are linearly independent, (b)
any d rows of Ψ are linearly independent, and (c) the diagonal
elements of Λ are all distinct. The choice of the matrix Ψ
governs the choice of the ﬁnite ﬁeld Fq , e.g., choosing Ψ
as Vandermonde (carefully chosen to satisfy condition (c))
permits any q ≥ 4n. The ((d = 2α ) × α ) message matrix M
is of the form M = [S1 S2 ]t , where S1 and S2 are (α × α )
symmetric matrices. The superscript t is used to denote the
transpose of a vector or matrix. The two symmetric matrices
S1 and S2 together contain α (α +1) distinct elements, which
are populated by the B = α (α + 1) message symbols. This
completes the description of the encoding algorithm.1
The following theorems show that this code is optimally
universally resilient during repair and reconstruction.
Theorem 1 (MSR Repair): In the MSR code presented, the
α symbols stored in any node can be recovered by downloading β symbols each from any ∆ = d + s + 2t nodes, in the
presence of upto s (block) erasures and t (block) errors.
Proof: Since we consider only block errors and erasures,
it sufﬁces to describe the repair algorithm for the code with
β = 1, and the same algorithm is applied in parallel to obtain
the repair algorithm for the desired code. Consider failure of
node f in the system, and let φt λf φt be the row of Ψ
f
f
corresponding to the failed node. Thus the α symbols stored
in node f are
λf φt M = φt S1 + λf φt S2 .
f
f
f

.

∆

Since any d rows of Ψ are linearly independent by construction, and since Ψrep comprises a subset of the rows of Ψ,
Ψrep mf is simply an MDS encoding of the d symbols in the
vector mf . It follows that this code has a minimum distance
of (∆ − d + 1) = (s + 2t + 1) which allows us to recover
mf using standard decoding algorithms [16] in the presence
of upto s erasures and t errors. Thus the replacement node
now has access to
S1 φf
.
m f = M φf =
S2 φf

Since both α and B are multiples of β, we obtain the optimal
code for the desired parameters (B, α, β) by ﬁrst constructing
an optimal code for

φt
f

2

B. Universally resilient MBR Codes
MBR codes achieve minimum possible download during
repair: a replacement node downloads only what it stores,
resulting in dβ = α. To meet the bound (1) with equality
(in absence of errors/erasures) an MBR code must satisfy
B=

kd −

k
2

β, α = dβ .

(8)

In this section we present explicit constructions of optimal,
universally resilient MBR codes for all parameter values
[n, k, d]. As in the MSR case, B and α are multiples of
β, and we ﬁrst construct codes for
B =

(7)

kd −

k
2

, α = d, β = 1 .

(9)

The desired code can be obtained by concatenating β copies
of this code.

1 The code can be converted to a systematic form (such as in Fig. 2) by a
simple symbol remapping technique as shown in [2, Section V-B].

4

5

The PM-MBR code in [2] has a similar form, C = Ψ M , as
the PM-MSR code. The MBR code has the (n × d) encoding
matrix Ψ of the form Ψ = [Φ Σ], where Φ is an (n × k)
matrix satisfying: (a) any k rows of Φ are linearly independent,
(b) any d rows of Ψ are linearly independent. For instance,
one can choose Ψ to be a Vandermonde matrix. The (d ×
d) message matrix M is symmetric and consists of the B
message symbols arranged as
S
Tt

M=

T
0

the same. To the best of our knowledge, the only codes today
that satisfy this condition are the product-matrix codes.
Theorem 5: An [n, k, d] regenerating code can be made
universally resilient if and only if the following condition
holds: during any instance of repair, the data passed by a node
h helping in the repair, to the failed node f , depends only on
h and f , and not on the identities of the other nodes helping
in this repair.
The proof of the theorem is provided in [11].
Remark 1: Clearly, since the number of nodes contacted
during repair must satisfy (d + s + 2t) ≤ (n − 1), the
requirement of having either s > 0 or t > 0 requires that
n > (d + 1). Thus the code should not restrict the number of
nodes n to be (d − 1).
The only explicit regenerating codes that support n > (d+1)
are the high-rate ‘approximately-exact’ MSR codes of [3] and
the product-matrix codes [2]. However, the MSR codes of [3]
do not satisfy the condition provided in Theorem 5. As shown
in Section III, the product-matrix codes satisfy this condition.

.

Here, the ((d − k) × k) matrix T and the (k × k) symmetric
matrix S contain the B = kd − k = k(d − k) + k(k+1)
2
2
message symbols as their elements.
The following theorems show that this code is optimally
universally resilient during repair and reconstruction.
Theorem 3 (MBR Repair): In the MBR code presented, the
α symbols stored in any node can be recovered by downloading β symbols each from any ∆ = (d + s + 2t) nodes, in the
presence of upto s (block) erasures and t (block) errors.
Proof: As in the case of MSR, it is sufﬁcient to describe
the repair algorithm for the code with β = 1. Consider
failure of node f in the system, and let ψ t be the row of Ψ
f
corresponding to the failed node. Thus the α symbols stored in
node f are ψ t M . We will follow the notation as in Theorem 1.
f
The helper node hj passes the symbol ψ t M ψ f . Denoting
hj
mf = M ψ f , the ∆ symbols obtained at the destination can
be written as Ψrep mf where

ACKNOWLEDGEMENT
The authors would like to thank Salim El Rouayheb and
Sameer Pawar for fruitful discussions.
R EFERENCES
[1] A. G. Dimakis, P. B. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran, “Network coding for distributed storage systems,” IEEE Trans. Inf.
Theory, vol. 56, no. 9, pp. 4539–4551, 2010.
[2] K. V. Rashmi, N. B. Shah, and P. V. Kumar, “Optimal exact-regenerating
codes for the MSR and MBR points via a product-matrix construction,”
IEEE Trans. Inf. Theory, vol. 57, no. 8, pp. 5227–5239, Aug. 2011.
[3] K. V. Rashmi, N. B. Shah, P. V. Kumar, and K. Ramchandran, “Explicit
construction of optimal exact regenerating codes for distributed storage,”
in Proc. Allerton Conf., Urbana-Champaign, Sep. 2009.
[4] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Explicit
codes minimizing repair bandwidth for distributed storage,” in Proc.
IEEE ITW, Cairo, Jan. 2010.
[5] C. Suh and K. Ramchandran, “Exact regeneration codes for distributed
storage repair using interference alignment,” in Proc. ISIT, Jun. 2010.
[6] I. Tamo, Z. Wang, and J. Bruck, “MDS array codes with optimal
rebuilding,” in Proc. IEEE ISIT, St. Petersburg, Jul. 2011.
[7] D. Papailiopoulos, A. Dimakis, and V. Cadambe, “Repair optimal erasure
codes through hadamard designs,” in Proc. Allerton Conf., 2011.
[8] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Distributed storage codes with repair-by-transfer and non-achievability of
interior points on the storage-bandwidth tradeoff,” IEEE Trans. Inf.
Theory, vol. 58, no. 3, 2012.
[9] S. Pawar, S. El Rouayheb, and K. Ramchandran, “Securing dynamic distributed storage systems against eavesdropping and adversarial attacks,”
IEEE Trans. Inf. Theory, vol. 57, no. 10, pp. 6734–6753, 2011.
[10] Y. Han, R. Zheng, and W. Mow, “Exact regenerating codes for byzantine
fault tolerance in distributed storage,” in Proc. INFOCOM, 2012.
[11] K. V. Rashmi, N. B. Shah, K. Ramchandran, and P. V. Kumar, “Unconditionally secure storage-bandwidth optimal distributed storage codes,”
in preparation.
[12] N. B. Shah, K. V. Rashmi, P. V. Kumar, and K. Ramchandran, “Interference alignment in regenerating codes for distributed storage: Necessity
and code constructions,” IEEE Trans. Inf. Theory, vol. 58, no. 4, 2012.
[13] N. Cai and R. Yeung, “Network error correction, ii: Lower bounds,”
Comm. in Information & Systems, vol. 6, no. 1, pp. 37–54, 2006.
[14] S. Jaggi, M. Langberg, S. Katti, T. Ho, D. Katabi, and M. M´ dard,
e
“Resilient network coding in the presence of byzantine adversaries,” in
INFOCOM, 2007.
[15] R. Koetter and F. Kschischang, “Coding for errors and erasures in
random network coding,” IEEE Trans. Inf. Theory, vol. 54, no. 8, pp.
3579–3591, 2008.
[16] F. MacWilliams and N. Sloane, The Theory of Error-Correcting Codes,
Part I. North-Holland Publishing Company, 1977.

t

Ψrep =

ψh ψh . . . ψh
1

2

.
∆

By construction, Ψrep mf corresponds to an MDS encoding of
the vector mf . As in the case of MSR, this code has minimum
distance of (∆−d+1) = (s+2t+1) which allows us to recover
mf in the presence of upto s erasures and t errors. Since the
message matrix M is symmetric, mt = ψ t M t = ψ t M is
f
f
f
precisely the set of α symbols required.
Theorem 4 (MBR Reconstruction): In the MBR code presented, a data-collector can reconstruct all the B message
symbols by downloading data stored in any κ = (k + s + 2t)
nodes in the presence of upto s (block) erasures and t (block)
errors.
Proof (sketch): As in the MSR case, the proof exploits
the reconstruction property of PM-MBR codes in the error-free
case [2]. The reconstruction property implies that, over Fα , the
q
minimum distance of the code is (κ − k + 1) = (s + 2t + 1).
This guarantees reconstruction of the k symbols over Fα , and
q
equivalently the B source symbols over Fq , in the presence of
upto s erasures and t errors.
Explicit data-reconstruction algorithms are provided in [11].
IV. N ECESSARY AND S UFFICIENT C ONDITIONS
The conversion of the product-matrix codes into universally
resilient codes, as described in Section III, raises a natural
question as to whether any regenerating code can be made
universally resilient in a similar manner. We answer this
question by providing a necessary and sufﬁcient condition for

5

