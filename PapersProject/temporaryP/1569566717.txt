Title:          final.pdf
Author:         hkaneko
Creator:         TeX output 2012.05.18:2012
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Fri May 18 20:18:59 2012
ModDate:        Tue Jun 19 12:54:28 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      501330 bytes
Optimized:      no
PDF version:    1.6
ISIT'2012 1569566717

Adaptive Synchronization Marker for
Insertion/Deletion/Substitution Error Correction
Masato Inoue and Haruhiko Kaneko
Graduate School of Information Science and Engineering
Tokyo Institute of Technology
2-12-1, Ookayama, Meguro-ku, Tokyo 152-8552, Japan.
Email: inoue@fuji.cs.titech.ac.jp, hkaneko@fuji.cs.titech.ac.jp
Abstract—This paper proposes an adaptive selection method
of synchronization marker to improve the error correction
capability of insertion/deletion/substitution error correcting code.
The adaptive markers are inserted into every d bits of a codeword
of LDPC code, where the marker value is determined depending
on the neighboring bits of the codeword. This paper also shows a
forward-backward algorithm to calculate the symbol-by-symbol
likelihood. Evaluation shows that the bit error rate of the
proposed method is lower than that of the conventional method
using ﬁxed synchronization marker.
Fig. 1.

I. I NTRODUCTION
Insertion/deletion/substitution error correction is required
in some practical systems. For example, bit-patterned media
(BPM) [1] require the precise synchronization of write signal
timing and the position of a bit island. However, perfect synchronization is impossible due to the jitter in the internal clock,
head vibrations, disk speed variations, and inaccurate positioning of the bit islands or variable bit island shapes. Therefore,
BPM suffers from insertion/deletion errors in the recorded
data. For multiple IDS error correction, conventional errorcorrecting codes, such as the Fire code, Reed-Solomon code
and LDPC code, however, cannot correct insertion/deletion
errors efﬁciently. Although Levenshtein code [2] has insertion/deletion/substitution (IDS) error correction capability, this
code cannot correct multiple IDS errors. Concatenation of
LDPC and watermark codes has been proposed in [3]. In
[4],[5], marker codes are used for synchronizations, that is,
insertion/deletion error can be reduced to a burst error of
moderate length by the marker code, and the error can be
corrected by LDPC code.
This paper proposes a method which adaptively selects
marker depending on neighboring bits of an LDPC codeword
in order to reduce missynchronization.
This paper is organized as follows. Section II explains
related works. Section III proposes adaptive synchronization
marker. Section IV shows simulation results, and Section V
concludes this paper.

Binary IDS channel [3].

TABLE I
C OMBINATION OF ERRORS [3].
Ins
0
0
0
1
1
1

lI
lI
lI

Del
1
0
0
1
0
0
.
.
.
1
0
0

Sub
0
1
0
1
0
1

Probability
Pd
Pt (1 − Ps )
Pt Ps
aI Pi Pd
aI Pi Pt (1 − Ps )
aI Pi Pt Ps
l

aI Pi I Pd
l
aI Pi I Pt (1 − Ps )
l
aI Pi I Pt Ps

Pi , ct is deleted with probability Pd , and ct is transmitted
with probability Pt = 1 − Pi − Pd . When ct was transmitted,
ct is substituted with probability Ps . For each ct , we assume
that maximum insertion length is lI . To take account of lI ,
a normalizing constant aI = 1/(1 − PilI ) is used. So, the
combination of errors and its occurrence probability are shown
in Table I.
B. IDS Error Correcting Code using LDPC Code and Marker
Code
1) Encoding: For a vector v = (v1 , v2 , . . . , vk ) and integers
i, j ∈ [1, k], vector [v]j is deﬁned as [v]j = (vi , vi+1 , . . . , vj ),
i
i
where i ≤ j. Let CE be a binary LDPC code of length nE and
rate RE . Each codeword cE ∈ CE is divided into subwords,
cE , cE , . . . , cE E /d , that is, the codeword is expressed as
1
2
n

II. R ELATED WORKS
A. IDS Channel
Figure 1 shows a binary IDS channel [3]. When the t-th
encoded bit ct is transmitted, one of the following events
occurs: a random bit is inserted before ct with probability

cE = cE , cE , . . . , cE E /d
1
2
n

1

,

TABLE II
E XAMPLE OF MARKER CODES [4].
nS
2
3
4

W
(1,0), (0,1)
(0,1,0), (1,0,1)
(0,1,1,0), (1,0,0,1)

where
cE =
i

(i ∈ [1, nE /d − 1])

[cE ]id
(i−1)d+1
[cE ]nE
(i−1)d+1

(i = nE /d ).

Let
W = {w1 , w2 , . . . , wm }
Fig. 2.

be the binary marker code of length nS , where each element
wj ∈ W is called a marker expressed as a binary vector of
length nS . The encoded word is generated by inserting markers
into every d bits of the LDPC codeword. The code length is
n = nE + nS nE /d . The code is expressed as

Calculation of α(t, s), β(t, s), and symbol-by-symbol likelihood.

In the equations, g1 (s, s ; x) is deﬁned as follows:
g1 (s, s ; x) = PIns (s − s − 1)PTran (s ; x)
+ PIns (s − s)Pd ,

C = (cE ,cS ,cE ,cS ,...,cEnE /d ,cSnE /d ) cE ∈ CE ,
1
1
2
2

where

where cS = wj ∈ W is the i-th marker for i ∈ [1, nE /d ].
i
The code rate of marker code is RS = nSd . Hence, the
+d
overall code rate is R = RE RS .
Table II presents example of marker codes [4]. When nS =
3, marker (0,1,0) and (1,0,1) are inserted into LDPC codeword
alternately.
2) Decoding: Let c = (c1 , . . . , cn ) ∈ C and r =
(r1 , . . . , rn ) be the encoded and received words, respectively.
For t ∈ [0, n] and s ∈ [0, n ], let Et,s be an event that t bits
are transmitted and s bits are received. Here, an event Et,s
corresponds the state of the hidden Markov model (HMM)
and the received word is considered as the output sequence
of the HMM. The state transition probabilities of the HMM
are calculated from the channel parameters. Also the output
probabilities are determined from the possible combination of
errors between the states Et,s and Et+1,s and the state index
t, which determines whether a transmitted bit is a part of the
marker or not.
To derive the probability of reaching to each state and the
symbol-by-symbol likelihood P (r|ct = x) from the given received word, the forward-backward (FB) algorithm is used. In
the FB algorithm, forward probability α(t, s) = P ([r]s , Et,s )
1
and backward probability β(t, s) = P ([r]n |Et,s ) are calcus+1
lated for t ∈ [1, n − 1] and s ∈ [0, n ] as follows:

⎧
⎪aI Pij
⎨
PIns (j) = 1
⎪
⎩
0

1 j
2

(1 ≤ j ≤ lI )
(j = 0)
(otherwise),

PTran (s; x) = P (rs |x)Pt .
The product term Pr(ct = x)g1 (s, s ; x) means the product
of the state transition probability and the output probability.
Initial values of α(t, s) and β(t, s) are given as follows:
α(0, s) =

1 (s = 0)
0 (otherwise),

β(n, s) =

1 (s = n )
0 (otherwise).

Figure 2 illustrates the calculation of α(t, s) and β(t, s) for
the case of lI = 1. In this ﬁgure, horizontal, vertical, and diagonal transitions represent insertion, deletion, and transmission,
respectively.
From α(t, s) and β(t, s), the symbol-by-symbol likelihood
P (r|ct = x) is calculated as follow:
n

s+lI +1

s=0

s =s

α(t − 1, s)g1 (s, s ; x)β(t, s ) .

P (r|ct = x) =

lI+1

α(t, s) =

Pr(ct = x)
x∈{0,1}

The log likelihood ratio is calculated as
used as soft input to the LDPC decoder.

α(t−1, s−k)g1 (s−k, s; x),
k=0

(1)
Pr(ct+1 = x)

x∈{0,1}

P (r |ct =0)
P (r |ct =1) ,

which is

III. A DAPTIVE S YNCHRONIZATION M ARKER

lI+1

β(t, s) =

(3)

Assume that cS = (1, 0, 1) ∈ W is a marker and a part of
encoded word is given as

β(t+1, s+k)g1 (s, s+k; x).
k=0

(2)

··· 1 1 0 1 0 1 0 0 1 ··· ,

2

Fig. 3.

Examples of adaptive decision of marker.
Fig. 4.

where the underlined part is the marker. In this case, consecutive three bits, which start from two bits left to the marker,
conforms with the marker. This situation might lead to poor
synchronization performance of the FB algorithm.
As shown in the above example, missynchronization might
occur when bit sequence around the marker coincides with the
marker. To avoid such a situation, this paper proposes adaptive marker. In this method, markers are adaptively decided
depending on an LDPC codeword.
The following presents structure of adaptive marker and its
decoding procedure. This paper focuses on nS = 3.

j
j
satisﬁes w1 = cE or w2 = cE , the candidate marker is
−2
−1
inserted into the LDPC codeword. As illustrated in Fig. 3(b),
j
j
if the candidate marker satisﬁes w1 = cE and w2 = cE , the
−2
−1
j
j
ﬁrst bit of candidate marker is reversed and (wj , w2 , w3 ) is
1
inserted into the LDPC codeword.

B. Decoding of adaptive marker
Since the ﬁrst bit cS of the adaptive marker cS is determined
1
i
depending on the preceding two codeword bits cE cE , the
−2 −1
values of cE cE cS are dependent, and hence the FB algorithm
−2 −1 1
is modiﬁed accordingly.
Let T be the the set of locations of the ﬁrst bit cS of the
1
markers given by

A. Structure of adaptive marker
The set W is deﬁned as
1
1
1
2
2
2
m
m
m
W = {(w1 , w2 , w3 ), (w1 , w2 , w3 ), . . . , (w1 , w2 , w3 )},

T = { t | t = id + (i − 1)nS + 1, i ∈ [1, nE /d − 1] } ,

where

and let Ti be the shifted set of T determined as

j
j
i
i
i
(w1 , w2 , w3 ) = (wj , w2 , w3 )
1

for i, j ∈ [1, m]. The set W

Ti = { t + i | t ∈ T }.

is deﬁned as

1
1
2
2
m
m
W = {(w1 , w2 , w3 ), (w2 , w2 , w3 ), . . . , (wm , w2 , w3 )}
1
1
1

The modiﬁed FB algorithm is described as follows.
Forward calculation: The initial values of α(t, s) is determined as α(0, 0) = 1 and α(0, s) = 0 for s ∈ [1, n ]. Then,
α(t, s) is determined for t ∈ [1, n − 1] as follows: (i) if
t ∈ T ∪ T−1 ∪ T−2 , then α(t, s) is calculated from α(t − 1, s)
/
using Eq. (1), and (ii) if t ∈ T , then α(t, s) is calculated from
α(t − 3, s) using Eq. (4), where g3 (s, s ; x1 x2 ) is given by
Eq. (8).
Backward calculation: The initial values of β(t, s) is determined as β(n, n ) = 1 and β(n, s) = 0 for s ∈ [0, n − 1].
Then, β(t, s) is determined for t ∈ [1, n − 1] as follows: (i) if
t ∈ T−1 ∪T−2 ∪T−3 , then β(t, s) is calculated from β(t+1, s)
/
using Eq. (2), and (ii) if t ∈ T−3 , then β(t, s) is calculated
from β(t + 3, s) using Eq. (5).
Calculation of likelihood: For non-marker locations t ∈
[1, n] \ (T ∪ T1 ∪ T2 ), the likelihood P (r|ct = x) is calculated
as follows: (i) if t ∈ T−2 , then P (r|ct = x) is calculated using
Eq. (6), (ii) if t ∈ T−1 , then using Eq. (7), and (iii) otherwise,
using Eq. (3).
Figure 4 illustrates the above FB algorithm.

= {(w1 , w2 , w3 ) | (w1 , w2 , w3 ) ∈ W }.
Marker code W is given as follows:
W =W ∪W
1
1
1
m
m
m
= {(w1 , w2 , w3 ), . . . , (w1 , w2 , w3 ),

1
1
m
m
(w1 , w2 , w3 ), . . . , (wm , w2 , w3 )}.
1
1

Let cE and cE be two codeword bits just before i-th marker
−2
−1
cS = (cS , cS , cS ). The i-th marker cS is selected as follows:
1
2
3
i
i
cS = (cS , cS , cS )
i
1
2
3
=

FB algorithm for adaptive marker.

j
j
j
j
(wj , w2 , w3 ) ((w1 , w2 ) = (cE , cE )),
−2 −1
1
j
j
j
(w1 , w2 , w3 ) (otherwise),

where j = (i mod m) + 1.
Example : Figure 3 shows examples of adaptive marker. In
j
j
j
this method, the candidate marker (w1 , w2 , w3 ) is compared
E
E
with the neighboring bits c−2 , c−1 , and then the marker is
decided. As illustrated in Fig. 3(a), if the candidate marker

3

3(lI +1)

α(t, s) =

Pr(ct−2 ct−1 ct = x2 x1 x0 )
x2 x1 x0 ∈{0,1}3

α(t − 3, s − k)g3 (s − k, s; x2 x1 x0 ),

(4)

k=0
3(lI +1)

β(t, s) =

Pr(ct+1 ct+2 ct+3 = x2 x1 x0 )
x2 x1 x0 ∈{0,1}3
n

P (r|ct = x) =

α(t − 1, s)g3 (s, s ; xx1 x0 )β(t + 2, s )

α(t − 2, s)g3 (s, s ; x2 xx0 )β(t + 1, s )

x2 x0 ∈{0,1}2

g3 (s, s ; x1 x2 x3 ) =

s=0 s =0

⎛

min(lI +1,s −s−i1 )

⎝

i1 =0

RS
R = RE RS

⎞

g1 (s, s + i1 ; x1 )g1 (s + i1 , s + i1 + i2 ; x2 )g1 (s + i1 + i2 , s ; x3 )⎠

(8)

i2 =0

TABLE III
C ODE PARAMETERS .

RE
d

(7)

n

Pr(ct−1 ct ct+1 = x2 xx0 )
lI +1

(6)

s=0 s =0
n

P (r|ct = x) =

(5)

n

Pr(ct ct+1 ct+2 = xx1 x0 )
x1 x0 ∈{0,1}2

LDPC code

β(t + 3, s + k)g3 (s, s + k; x2 x1 x0 )
k=0

code (a)

code (b)

1
2

5
6

the former case is 19 = 0.475, while that of the latter case is
40
2
3 = 0.667. Therefore, to improve the insertion/deletion error
correction capability, inserting many markers is more effective
than using strong LDPC codes. Further, the effect of adaptive
marker increases when there are many markers. However, the
amount of calculation in FB algorithm increases.

12

27

57

12

27

57

4
5
2
5

9
10
9
20

19
20
19
40

4
5
2
3

9
10
3
4

19
20
19
24

V. C ONCLUSION
This paper has proposed the adaptive marker, which can be
applied to insertion/deletion/substitution error-correcting codes
constructed with LDPC codes and marker codes. We have
presented the structure of adaptive marker and its decoding
method. Evaluations have shown that the adaptive marker
improves synchronization capability in FB algorithm.
Further research will be required to construct more general
adaptive marker codes, such as codes with length nS ≥ 4, and
also to develop decoding algorithm for the generalized codes.
In addition, it should be discussed which marker codes are
suitable for the adaptive selection method.

IV. E VALUATION
The bit error rate (BER) is evaluated under the following
conditions :
• LDPC code length : nE = 1944
1
5
• LDPC code rate : RE = 2 (code (a)), 6 (code (b))
• Length of marker code : nS = 3
• Marker interval : d = 12, 27, 57
The LDPC codes are selected from [6], and the adaptive marker code is determined as W = W ∪ W =
{(0, 1, 0), (1, 0, 1)} ∪ {(1, 1, 0), (0, 0, 1)}. For comparison, the
BER of the conventional ﬁxed marker coding is also evaluated, where the marker code is {(0, 1, 0), (1, 0, 1)}. Table III
summarizes the above coding parameters.
Figure 5 shows the BER for Ps = 0.0 using LDPC code
(a), Fig. 6 the BER for Ps = 0.01 using LDPC code (a),
and Fig. 7 the BER for Ps = 0.0 using LDPC code (b),
respectively. Here, Figs. 5(a), 6(a), and 7(a) show the BER
for the word which is determined from the symbol-by-symbol
likelihood at the end of the FB algorithm, and Figs. 5(b), 6(b),
and 7(b) show the BER for the decoded word of the sumproduct algorithm.
From Figs. 5(a), 6(a), and 7(a), as insertion and deletion
probabilities become higher, the difference of BERs between
the adaptive marker and the ﬁxed marker increases. Thus,
the adaptive marker is effective to improve synchronization
capability.
For Ps = 0.0 and 0.05 ≤ Pi = Pd ≤ 0.07, the BER of
LDPC code (a) with marker interval d = 57 is the same as
the BER of LDPC code (b) with d = 12. The code rate of

R EFERENCES
[1] K. Naito, H. Hieda, M. Sakurai, Y. Kamata, and K. Asakawa, “2.5-inch
disk patterned media prepared by an artiﬁcially assisted self-assembling
method,” IEEE Trans. Magn, vol. 38, no. 5, pp. 1949-1951, 2002.
[2] V. I. Levenshtein, “Binary codes capable of correcting deletions, insertions, and reversals, ” Soviet Physics Doklady, vol. 10, no. 8, pp. 707-710,
1966.
[3] M. C. Davey and D. J. C. Mackay, “Reliable communication over
channels with insertions, deletions, and substitutions, ” IEEE Trans.
Information Theory, vol. 47, no.2, pp. 687-698, 2002.
[4] M. Kobayashi, G. Hosoya, H. Yagi, and S. Hirasawa, “A decoding
algorithm for LDPC codes over insertion/deletion/substitution channels,
” Proc. SITA2010, pp. 432-237, 2010.
[5] F. Wang, D. Fertonani, and T. M. Duman “Symbol-level synchronization
and LDPC code design for insertion/deletion channels,” IEEE Trans.
Communications, vol. 59, no. 5, pp. 1287-1297, 2011.
[6] IEEE Std 802.11n TM -2009.

4

0.11
1e-02
0.1

1e-03

0.08
BER

BER FBA

0.09

0.07
1e-04

0.06

fixed
adaptive
fixed
adaptive
fixed
adaptive

0.05
0.04

0

0.005

0.01

0.015
Pi=Pd

Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0

d=12
d=12
d=27
d=27
d=57
d=57

0.02

0.025

(a) BER after FB algorithm.
Fig. 5.

1e-05

0.03

fixed
adaptive
fixed
adaptive
fixed
adaptive
0

0.005

0.01

BER performance (Ps = 0.0, LDPC code (a)).

0.015
Pi=Pd

Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0

0.02

d=12
d=12
d=27
d=27
d=57
d=57
0.025

0.03

(b) Decoded BER.

0.11
1e-02
0.1

1e-03
BER

BER FBA

0.09

0.08

0.07

1e-04
fixed
adaptive
fixed
adaptive
fixed
adaptive

0.06

0.05
0.002 0.004 0.006 0.008

0.01

Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01

d=12
d=12
d=27
d=27
d=57
d=57

0.012 0.014 0.016 0.018
Pi=Pd

(a) BER after FB algorithm.
Fig. 6.

0.02

1e-05
0.002 0.004 0.006 0.008

0.022

fixed
adaptive
fixed
adaptive
fixed
adaptive
0.01

Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01
Ps=0.01

d=12
d=12
d=27
d=27
d=57
d=57

0.012 0.014 0.016 0.018
Pi=Pd

0.02

0.022

(b) Decoded BER.
BER performance (Ps = 0.01, LDPC code (a)).

0.045
1e-02
0.04

1e-03

0.03
BER

BER FBA

0.035

0.025
1e-04

0.02

fixed
adaptive
fixed
adaptive
fixed
adaptive

0.015
0.01

0

0.001

0.002

0.003

0.004
Pi=Pd

0.005

Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0

d=12
d=12
d=27
d=27
d=57
d=57

0.006

(a) BER after FB algorithm.
Fig. 7.

0.007

1e-05

0.008

fixed
adaptive
fixed
adaptive
fixed
adaptive
0

0.001

0.002

BER performance (Ps = 0.0, LDPC code (b)).

5

0.003

0.004
Pi=Pd

0.005

(b) Decoded BER.

Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
Ps=0.0
0.006

d=12
d=12
d=27
d=27
d=57
d=57
0.007

0.008

