Creator:        TeX
Producer:       Appligent StampPDF Batch, version 5.1
CreationDate:   Mon Apr 30 13:56:11 2012
ModDate:        Tue Jun 19 12:54:33 2012
Tagged:         no
Pages:          5
Encrypted:      no
Page size:      612 x 792 pts (letter)
File size:      567657 bytes
Optimized:      no
PDF version:    1.6
ISIT'2012 1569565257

Reducing complexity of tail-biting trellises
Heide Gluesing-Luerssen

G. David Forney, Jr.

University of Kentucky
Department of Mathematics
Lexington, KY 40506
Email: heide.gl@uky.edu

Laboratory for Information and Decision Systems
Massachusetts Institute of Technology
Cambridge, MA 02139
Email: forneyd@comcast.net

A linear block code C over a ﬁnite ﬁeld F is a subspace of
a symbol sequence space A = Πm−1 Ai , where each symbol
i=0
alphabet Ai is a ﬁnite-dimensional vector space over F.
A linear tail-biting trellis realization (for short: trellis) is
a collection of state spaces Si and local constraint codes Ci
such that all spaces are ﬁnite-dimensional over F and Ci ⊆
Si × Ai × Si+1 for all i ∈ Zm := {0, . . . , m − 1} (with
index computation modulo m). The state sequence space is
m−1
deﬁned as S = i=0 Si , and the elements of Ci are called
branches. The behavior of the realization is the set B of all
pairs (a, s) ∈ A × S such that all constraints are satisﬁed;
i.e., (si , ai , si+1 ) ∈ Ci for all i. The code C generated by
the realization is the set of all a ∈ A that appear in some
(a, s) ∈ B. Note that conventional trellis realizations may
simply be regarded as the special case where S0 is trivial.
A trellis realization of the code C is observable if for each
a ∈ C there is precisely one pair (a, s) ∈ B. The realization
is state-trim (resp. branch-trim) if each state (resp. branch)
appears on a valid trajectory. We say that a constraint code Ci
is trim if both the projections of Ci onto Si and onto Si+1
are surjective. A constraint code Ci is proper if there are no
nonzero branches of the form (si , 0, 0) or (0, 0, si+1 ) in Ci .
Finally, we introduce the main concept of this note.

Abstract—It is shown that a trellis realization can be locally
reduced if it is not state-trim, branch-trim, proper, observable,
and controllable. These conditions are not sufﬁcient for local
irreducibility. Making use of notions that amount to “almost
unobservability/uncontrollability”, a necessary and sufﬁcient criterion of local irreducibility for tail-biting trellises is presented.

I. I NTRODUCTION
This paper deals with tail-biting trellis realizations for linear
block codes. They form the simplest type of realizations on
graphs with cycles. The latter have gained a lot of interest
because they are often simpler than realizations on cycle-free
graphs and thus may give rise to more powerful iterative decoding algorithms (e.g., LDPC codes). Unfortunately, minimal
realization theory turns out to be much more challenging for
graphs with cycles than for graphs on a ﬁnite conventional
time axis, see [8] and the references therein, and even on
general cycle-free graphs, see [3]. The discussion in [7] nicely
illustrates the difﬁculties for the special case of tail-biting
trellis realizations.
In this note we will study tail-biting trellis realizations
with the goal to reduce their complexity by a local reduction
process. We ﬁrst present necessary criteria for local irreducibility of such realizations. They amount to well-known basic
trellis properties. Secondly, we give a sufﬁcient criterion. This
criterion is less obvious, and our approach will reveal how the
normal graph dualization as derived in [1] helps to uncover
defects of realizations that are otherwise not immediately
evident. In fact, it turns out to be beneﬁcial to investigate a
trellis and its dual simultaneously.
Finally, we will relate our results to the approach taken
by Koetter and Vardy [7], who narrowed down the class
of potentially minimal tail-biting trellises by making use of
product constructions.
We wish to mention that the results presented in Sections II and III generalize straightforwardly to general normal
graphs [3], [4], but it is open whether Section IV can be
generalized as well.

Deﬁnition I.1 A local reduction of a trellis is a replacement of one state space, say Si , and the incident constraint
codes Ci−1 and Ci by spaces of at most the same dimension
while all other spaces remain unchanged such that the resulting
trellis represents the same code. We call a local reduction strict
if the state space dimension is strictly reduced. A realization is
called locally irreducible if each local reduction is isomorphic
to the primal realization.
Obviously, if no dimension is reduced then the terminology
“local reduction” is not quite justiﬁed, and “local alteration”
may be more appropriate. But we will see later (Theorem IV.4)
that a local reduction is always either strict or results in a
trellis that allows a subsequent strict local reduction so that
ultimately we achieve a net reduction of the trellis complexity.
The main tools for locally reducing a trellis are the mutually dual processes of trimming and merging. They will be
discussed in Section III. It will be shown that they allow us
to reduce a trellis and its dual simultaneously.

We ﬁx the following notations pertaining to tail-biting trellis
realizations.
The work of the second author was supported in part by National Science
Foundation grant #DMS-0908379.
This conference note is based on the preprints [3], [4].

1

Let T and T be two trellis realizations of the code C with
index set {0, . . . , m − 1}. Denote the state spaces and constraint codes by Si , Ci and Si , Ci , respectively. We say that T
is obtained from T by trimming the state space Si , if Si is a
subspace of Si and Ci−1 = {(si−1 , ai−1 , si ) ∈ Ci−1 | si ∈ Si }
and Ci = {(si , ai , si+1 ) ∈ Ci | si ∈ Si }, while all other state
spaces and constraint codes of T and T coincide.
The dual of state-trimming is an instance of what is known
as merging in the literature of trellis realizations. In our case,
merging has to be done by taking a suitable quotient space in
order to keep the linearity of the resulting trellis. Precisely,
we say the realization T is obtained from T by merging
at time i if Si = Si /Y for some subspace Y ⊆ Si and if
Ci−1 = {(si−1 , ai−1 , si + Y) | (si−1 , ai−1 , si ) ∈ Ci−1 } and
similarly Ci = {(si + Y, ai , si+1 ) | (si , ai , si+1 ) ∈ Ci }. Again,
all other state spaces and constraint codes of T and T coincide. It follows from projection/cross-section duality that T
is obtained from T by trimming Si to the subspace Y if and
ˆ
ˆ
only if (T )◦ is obtained from T ◦ by merging Si to Si /Y ⊥ .
In general, the trimmed/merged realization generates a different code than the original realization. We will, of course,
be interested in the case where the code generated does not
change after trimming/merging. In this case, trimming and
merging obviously form simultaneous local reductions of the
trellis and its dual in the sense of Deﬁnition I.1.
Now we can present a ﬁrst list of necessary conditions for
local irreducibility.

II. D UALITY
We brieﬂy recall the basic duality notions.
If V is a ﬁnite-dimensional vector space over F, then its dual
ˆ
space V is deﬁned to be the linear algebra dual of V . Thus
ˆ
we have an inner product on V × V . For a subspace W ⊆ V
⊥
ˆ is deﬁned as the space of
the orthogonal space W ⊆ V
ˆ
all vectors in V that are orthogonal to all vectors in W . For
further properties we refer to [1], [3].
Following the normal graph dualization introduced in [1],
we deﬁne the dual of a trellis T as the trellis with the same
index set in which the symbol alphabets Ai , Si are replaced by
ˆ ˆ
their dual spaces Ai , Si , the constraint codes Ci are replaced
⊥
ˆ
ˆ
ˆ
by their orthogonal spaces Ci ⊆ Si × Ai × Si+1 , and the
sign of each dual state variable is inverted in one of the two
constraints in which it is involved. The Normal Graph Duality
Theorem [1] states that if T realizes a linear code C, then its
dual, denoted by T ◦ , realizes the orthogonal code C ⊥ .
A main tool in dualization is projection/cross-section duality, for which we refer to [1, Thm. 7.2] or [3, Sec. 2.5]. As a
ﬁrst application one obtains the following [6], [3].
Theorem II.1 The constraint code Ci of a trellis T is trim if
⊥
and only if the dual constraint code Ci of T ◦ is proper.
We call a realization T controllable if the constraints
⊥
ˆ ˆ
Ci , i ∈ Zm , are linearly independent (in A × S). A detailed
discussion and justiﬁcation of this terminology can be found
in [3], where also the following has been proved.

Theorem III.1 Any locally irreducible realization is statetrim, proper, observable, and controllable. More precisely, if a
realization T lacks any of these properties, then there exists a
strict local reduction of T , and the dual process is a strict local
reduction of T ◦ .

Theorem II.2 A trellis T is controllable if and only if the dual
trellis T ◦ is observable. Moreover, T is controllable if and only
if dim B = i dim Ci − dim S.
Example II.3 This example appeared ﬁrst in [5], [6]. Figure 1(a) shows the product trellis with symbol spaces Ai = F2
for i ∈ Z4 , obtained from the generators 01110, 10010, 01 101
with the indicated circular spans. The dashed (resp. solid)
lines denote symbol variable 0 (resp. 1). The dual trellis is
ˆ
in Figure 1(b). Note that we chose Si = Si and the standard
inner product for all state spaces and that no sign inverter is
needed. Both trellises are state-trim, proper, observable and
controllable. But the trellis in 1(b) is not branch-trim. We will
see in the next section that both trellises are locally reducible.

Figure 1(a)

Proof: If T is not state-trim or not proper, then we can
trim either T or T ◦ (see Theorem II.1). The dual process is a
merging, and we obtain strict local reductions for T and T ◦ .
Next, suppose T is unobservable. Precisely, let (0, s) be a nontrivial unobservable trajectory and let si ∈ Si be a nonzero
state on this trajectory. Let Ti be a subspace of Si such that
Ti ⊕ si = Si . It is not hard to see ([3]) that the realization
obtained by trimming Si to Ti still generates the same code.
Thus we have obtained a strict local reduction. The dual
process is a suitable state merging of T ◦ , and this again is
a strict local reduction. This also shows that uncontrollable
realizations are locally reducible.
Note that the trellises in Figure 1 have all the necessary
conditions of the previous theorem, and thus this simple test
does not imply their local reducibility. In fact, we need to make
use of the fact that the trellis in Figure 1(b) is not branch-trim.
The following notion will be crucial for our further investigation. It addresses non-branch-trimness in a way that
is naturally dualizable. This will allow us to uncover the
shortcomings of the trellis in Figure 1(a).

Figure 1(b)

III. N ECESSARY C RITERIA FOR L OCAL I RREDUCIBILITY
In this section we turn to local reductions of a given trellis.
In essence, all constructions will amount to trimming (i.e.,
restricting) or merging (i.e., “quotienting”) a particular state
space. Thus, let us discuss these constructions in detail.

2

Deﬁnition III.2 An observable and controllable trellis is
called span-one-uncontrollable (resp. span-one-unobservable)
if we can replace one constraint code by a proper subspace
(resp. superspace) without changing the code realized by the
trellis.

in Figure 2(b). The dual process consist of expanding the last
constraint code in the trellis in Figure 1(a) by one dimension,
namely by adding the branch (01|0|01) to the generators of
this constraint code. This results in the unobservable trellis in
Figure 2(a), which then is the dual of that in Figure 2(b).

Evidently, an observable and controllable trellis is span-oneuncontrollable if and only if it is not branch-trim. Moreover, a
trellis T is span-one-uncontrollable if and only if its dual T ◦
is span-one-unobservable. This follows immediately from the
⊥
˜
˜⊥
equivalence Ci ⊂ Ci ⇔ Ci ⊃ Ci , which also shows that
replacing a constraint code by a proper subspace or superspace
are mutually dual processes. Furthermore, if T is span-oneuncontrollable, then a branch-trimming (i.e., replacing a constraint code by a proper subcode) results in an uncontrollable
trellis. This is a direct consequence of Theorem II.2. Dually, a
span-one-unobservable trellis will become unobservable after
branch-addition (replacing a constraint code by a proper
supercode). This explains the terminology.

Figure 2(a)

Figure 2(b)

Now we can trim the ﬁrst trellis at state time 4 to the subspace
{00, 11} and merge the dual state space to F2 /{00, 11}.
2
This results in the mutually dual trellises shown in Figure 3. These trellises still generate the original code C =
01110, 10010, 01101 and its dual C ⊥ , respectively. Notice
that they form strict local reductions of the trellises in Figure 1
in the sense of Deﬁnition I.1.

Now we can formulate another necessary condition for local
irreducibility.
Theorem III.3 Let T be span-one-unobservable. Then T allows a strict local reduction. The dual process is a strict local
reduction of T ◦ , and thus span-one-uncontrollable trellises are
locally reducible as well.

Figure 3(a)

Figure 3(b)

Is is worth emphasizing that the trellis in Figure 1(a) is
locally reducible, even though it is state-trim, proper, branchtrim, observable, controllable, and non-mergeable (i.e., no state
space can be merged without changing the code generated
by the trellis). We ﬁrst had to perform an auxiliary branchaddition before a state-trimming resulted in a net reduction of
the trellis complexity.

Proof: Let T be span-one-unobservable (but observable).
Then T ◦ is span-one-uncontrollable and we may replace a
⊥
˜⊥
constraint code, say Ci , by a strict subspace, say Ci , without
changing the code generated by the realization. Without loss
⊥
˜⊥
of generality we may assume dim Ci = dim Ci − 1. Theo˜
rem II.2 shows that the resulting realization, denoted by T ◦ , is
uncontrollable. The dual process is the expansion of the con˜
˜
straint code Ci to the superspace Ci where dim Ci = dim Ci +1,
˜
and by Theorem II.2 we obtain an unobservable realization T .
˜
Thus by Theorem III.1 the trellis T can be trimmed. We have
to do this carefully in order to decrease the dimension of
˜
the enlarged constraint code Ci . Since T is observable, but
˜
˜
T is not, there exists a nonzero branch (si , 0, si+1 ) ∈ Ci \Ci .
Without loss of generality, let si = 0 and thus we may trim
the state space Si as described in the proof of Theorem III.1.
ˆ
The resulting realization, denoted by T , has a strictly smaller
˜
state space and constraint code at time i than T . Hence the
ˆ
ﬁnal constraint code dimensions of T are not larger than those
of T , and we have performed a strict local reduction of T . The
dual process is a strict local reduction of T ◦ because it is a
branch-trimming followed by a state-merging.

The necessary conditions for local irreducibility we have
presented so far are not sufﬁcient. For instance, the trellises
in Figure 3 are state-trim, branch-trim, proper, span-oneobservable, and span-one-controllable. Yet they are still locally
reducible, as we will see in the next section.
IV. S UFFICIENT C ONDITION OF L OCAL I RREDUCIBILITY
In this section we will present a characterization of local
irreducibility of tail-biting trellises. For ease of notation, we
will restrict ourselves to trellis realizations with symbol spaces
Ai = F for all i. The results can straightforwardly be
generalized to arbitrary trellises. Following the usual notation,
all trellises will have length n and thus generate codes in Fn .
Let us return to span-one-unobservable trellises. We have
the following alternative description.

Now we can reduce the trellises in Figure 1.
Example II.3 (cont.) The trellis in Figure 1(b) is spanone-uncontrollable. Indeed, the trellis is not branch-trim, and
deleting the four diagonal branches of the last constraint code
does not change the code generated by that trellis. Thus, the
trellis and its dual in Figure 1(a) are locally reducible. Deleting
those four diagonal branches renders the uncontrollable trellis

Proposition IV.1 An observable and controllable trellis is
span-one-unobservable if and only if there exists a nontrivial
path of length n−1 representing the zero word (of length n−1).
Proof: It is clear from the paragraph after Deﬁnition III.2
that a span-one-unobservable trellis must contain such a path.

3

Conversely, let T be observable and controllable with behavior B, and let T contain a nontrivial path of length n − 1
representing the zero word. Suppose the path passes through
the states s1 , s2 , . . . , s0 . Replace the constraint code C0 by
C0 + (s0 |0|s1 ) . Then the new realization contains B and the
new unobservable trajectory (0, s), where s = (s0 , . . . , sn−1 ).
But since the constraint code increases by just one dimension,
the behavior can also increase by at most one dimension.
Thus, the behavior is given by B + (0, s), and the new trellis
still generates the same code. This shows that T is span-oneunobservable.

Proof: We have seen already in Theorems III.1 and III.3
that if a trellis is not state-trim, branch-trim, proper, spanone-observable/controllable, then it and its dual are locally
reducible. If a trellis has all these properties, but is not
span-two-observable, then a local reduction is illustrated in
Example IV.5 below. The detailed proof can be found in [4].
Let us sketch the proof for (ii) ⇒ (i). The remaining
statements follow easily. Thus, let T be a trellis as in (ii).
˜
˜
Suppose T is a local reduction of T with state space S1 and
˜0 and C1 , while all other spaces of T and T
˜
˜
constraint codes C
˜
coincide. We have to show that T and T are isomorphic,
that is, they coincide up to state space isomorphisms. Without
˜
loss of generality we may assume that T is trim and proper
at state time 1, and thus at all times. One can easily see
˜
˜
˜
that T and T ◦ are observable. Let dim S1 = dim S1 − m
˜i = dim Ci − i for i = 0, 1, where m, o , 1 ≥ 0.
and dim C
With the aid of Theorem II.2 one derives straightforwardly
0 + 1 = m.
We show next that o = 1 = m = 0. To this end,
let (s0 , a0 , s1 ) ∈ C0 . This branch belongs to a valid trajectory in T , say (a, s). By observability, there is a unique
˜
valid trajectory (a, ˜) in T , and thus we obtain a branch
s
˜0 . Using properness of T and T , this gives
˜
(s0 , a0 , s1 ) ∈ C
˜
˜
rise to a well-deﬁned, injective linear map ϕ0 : C0 → C0 ,
˜0 ≥
(s0 , a0 , s1 ) → (s0 , a0 , s1 ). As a consequence, dim C
dim C0 . But then we have equality and ϕ0 is an isomorphism.
˜
In the same way dim C1 = dim C1 and there is an isomorphism
˜1 , (s1 , a1 , s2 ) → (s , a1 , s2 ). Now 0 + 1 = 0
ϕ1 : C1 → C
1
˜
implies m = 0, thus dim S1 = dim S1 , and the given local
reduction is not strict.
Finally, by Proposition IV.3, for each s2 ∈ S2 and
s0 ∈ S0 there exists a path in T starting in s2 and ending
in s0 . As a consequence, each path (s0 , a0 , s1 , a1 , s2 ) of
length 2 in T is part of a valid trajectory in T . This in
turn yields that for each such path (s0 , a0 , s1 , a1 , s2 ) there
˜
exists some s1 ∈ S1 such that ϕ0 (s0 , a0 , s1 ) = (s0 , a0 , s1 )
˜
˜
and ϕ1 (s1 , a1 , s2 ) = (˜1 , a1 , s2 ). This way we obtain a
s
˜
˜
well-deﬁned isomorphism ψ : S1 → S1 such that C0 =
˜1 . But
{(s0 , a0 , ψ(s1 )) | (s0 , a0 , s1 ) ∈ C0 } and similarly for C
˜
this simply means that T and T are isomorphic trellises.

All of this suggests to extend the notion of span-oneobservability to longer spans. However, for our purpose
of local reductions it will sufﬁce to consider span-twoobservability/controllability.
Deﬁnition IV.2 A trellis realization of length n is called spantwo-observable if it does not contain a nontrivial path of
length n − 2 representing the zero word. A trellis is called
span-two-controllable if its dual is span-two-observable.
Evidently span-two-observability implies span-one-observability implies observability. Span-two-controllability can be
characterized as follows.
Proposition IV.3 A trim trellis is span-two-controllable if and
only if, for each i ∈ Zm , each pair of states in Si and Si−2 are
connected by a path of length n − 2.
Proof: Without loss of generality let i = 2. Let P be
the set of all paths in the trellis T starting at time 2 and
ending at time 0. Then the projection P|S2 ×S0 is the set of all
state pairs that are connected by such a path. With the aid of
projection/cross-section duality one obtains that (P|S2 ×S0 )⊥
ˆ
ˆ
is the space of all pairs in S2 × S0 that are connected by a
◦
path in T that represents the zero word. Since T ◦ is proper,
it is span-two-observable if and only if this space is trivial.
This in turn is equivalent to P|S2 ×S0 = S2 × S0 . This proves
the desired result.
Now we can formulate our main result characterizing local
irreducibility.

Example IV.5 Consider the trellises given in Figure 4 below.
The trellis in Figure 4(a) is the product trellis of the code C
generated by 110010, 001 110, 100011 with the indicated
spans. (The code C ⊥ does not satisfy the requirements of
Theorem IV.4. But the example still illustrates the main
arguments of the general proof; this is due to the fact that
the reduction is based on span-two-unobservability and not
span-two-uncontrollability). The trellis is state-trim, branchtrim, proper, observable, and controllable. It is also spanone-observable and span-one-controllable, but not span-twoobservable: it contains a path starting at the state 11 ∈ S4 ,
ending at 10 ∈ S2 , and representing the zero word. This will
allow us to perform a local reduction by changing the state
space S3 and its incident constraint codes C2 , C3 . In a ﬁrst
step we expand S3 by introducing an additional state, say

Theorem IV.4 Let C ⊆ Fn be a code such that both C and C ⊥
do not contain any codewords that are supported by an interval
of length at most 2. Let T be a trellis realization of C. Then the
following are equivalent.
(i) T is locally irreducible.
(ii) T is state-trim, branch-trim, proper, span-two-observable
and span-two-controllable.
(iii) T ◦ is locally irreducible.
(iv) T ◦ is state-trim, branch-trim, proper, span-two-observable
and span-two-controllable.
Furthermore, if T is locally reducible, then it allows either a
strict local reduction or a local reduction which gives rise to a
subsequent strict local reduction. In either case, the dual process
is a reduction of the same type for T ◦ .

4

˜
˜
S3 := S3 + s , and expand C2 and C3 to C2 = C2 + (10|0|˜)
˜
s
˜3 = C3 + (˜|0|11) . It is not hard to see that the resulting
and C
s
trellis, shown in Figure 4(b), still represents the code C. By
construction, it is unobservable and thus can be trimmed as in
˜
the proof of Theorem III.1. If we trim the state space S3 to
the subspace 1 + s , we obtain the trellis in Figure 4(c). This
˜
trellis forms a local reduction of the original trellis where no
state space and constraint code dimension has changed. But
the new trellis is obviously not trim, and thus we may trim it
at state time 4, resulting in the trellis shown in Figure 4(d).
This illustrates the main idea of the proof of (i) ⇒ (ii) in
Theorem IV.4: one can show that for a span-two-unobservable
trellis there always exists an extension of one state space
followed by a trimming that results in a non-trim trellis, which
then can be further reduced.
It is easy to see that dualizing the preceding steps leads to
a two-step local reduction of the dual trellis.
The trellis in Figure 4(d) is state-trim, branch-trim, proper,
span-two-observable, span-one-controllable, but not span-twocontrollable. Thus it can be further locally reduced.

Let us compare our results with previous work on tailbiting trellises with potentially low complexity. To this end, we
restrict ourselves again to trellises with symbol spaces Ai = F
for all i. Koetter and Vardy [7] showed that the search for
possibly minimal linear tail-biting trellis realizations could
be narrowed to a certain canonical class, which we call
KV-trellises (here minimal refers to Θ-minimal in the sense
of [7]). A KV-trellis is a product realization with dim C linearly
independent generators, each of which has the shortest circular
span of any codeword whose span starts (or stops) at the
same position [5], [6]. The construction may be regarded as
the tail-biting version of the “shortest basis” approach [2].
KV-trellises are state-trim, branch-trim, proper, observable and
controllable [7].
Now we can give an overview of various trellis classes.
Let us write S1O, S2O, S1C, S2C for span-one-observability, span-two-observability, and the dual controllability notions.
We also denote “state-trim, branch-trim and proper” by T/P,
and “observable and controllable” by O/C.
With the machinery developed in [6], one can show that
if a code does not contain any span-two codewords, then its
KV-trellises are S2O. Thus, if both the code and its dual do
not contain any span-two codewords (a requirement that is not
met by the examples in this note), then their KV-trellises are
S2O and S2C. On the other hand, there exist examples of T/P
and S2O/S2C trellises that are not KV. All of this leads to the
following strict containments of classes of tail-biting trellises
for a given code (assuming that neither the code nor its dual
contains any span-two codewords):

Figure 4(a)

{minimal} {KV}
{T/P, O/C}.
Figure 4(b)

{T/P, S2O/S2C}

{T/P, S1O/S1C}

Furthermore, the four trellis classes in the top row are invariant
under taking duals, whereas the one in the bottom row is
not. The set {T/P, S2O/S2C} is exactly the class of locally
irreducible trellises.
R EFERENCES

Figure 4(c)

[1] G. D. Forney, Jr. Codes on graphs: Normal realizations. IEEE Trans.
Inform. Theory, IT-47:520–548, 2001.
[2] G. D. Forney, Jr. Minimal realizations of linear systems: The “shortest
basis” approach. IEEE Trans. Inform. Theory, IT-57:726–737, 2011.
[3] G. D. Forney, Jr. and H. Gluesing-Luerssen. Codes on graphs: Observability, controllability and local reducibility. Preprint, 2012. Submitted.
ArXiv: cs.IT/1203.3115v1.
[4] H. Gluesing-Luerssen and G. D. Forney, Jr. Local reducibility of tailbiting trellises. In preparation, 2012.
[5] H. Gluesing-Luerssen and E. Weaver. Linear tail-biting trellises: Characteristic generators and the BCJR-construction. IEEE Trans. Inform.
Theory, IT-57:738–751, 2011.
[6] H. Gluesing-Luerssen and E. Weaver. Characteristic generators and
dualization for tail-biting trellises. IEEE Trans. Inform. Theory, IT57:7418–7430, 2011.
[7] R. Koetter and A. Vardy. The structure of tail-biting trellises: Minimality
and basic principles. IEEE Trans. Inform. Theory, IT-49:2081–2105,
2003.
[8] A. Vardy. Trellis structure of codes. In Handbook of Coding Theory,
Vol. 2 (V. S. Pless and W. C. Huffman, eds.), pages 1989–2117. Elsevier,
Amsterdam, 1998.

Figure 4(d)
In the same manner the trellis in Figure 3(a) can be locally
reduced.
V. S UMMARY FOR TAIL - BITING TRELLISES
We have given a complete description of tail-biting trellises
that are locally irreducible in the sense of Deﬁnition I.1. Our
methods were solely based on intrinsic trellis properties, and
no speciﬁc representation like the product construction was
used. Furthermore, we provided constructive procedures of
how to reduce a given trellis (and its dual).

5

